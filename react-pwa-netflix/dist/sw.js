/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/idb/build/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unwrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   \"wrap\": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   \"deleteDB\": () => (/* binding */ deleteDB),\n/* harmony export */   \"openDB\": () => (/* binding */ openDB)\n/* harmony export */ });\n/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ \"./node_modules/idb/build/esm/wrap-idb-value.js\");\n\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\n\nfunction openDB(name, version, {\n  blocked,\n  upgrade,\n  blocking,\n  terminated\n} = {}) {\n  const request = indexedDB.open(name, version);\n  const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);\n\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', event => {\n      upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));\n    });\n  }\n\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  openPromise.then(db => {\n    if (terminated) db.addEventListener('close', () => terminated());\n    if (blocking) db.addEventListener('versionchange', () => blocking());\n  }).catch(() => {});\n  return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\n\n\nfunction deleteDB(name, {\n  blocked\n} = {}) {\n  const request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', () => blocked());\n  return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\n\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) {\n    return;\n  }\n\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  const targetFuncName = prop.replace(/FromIndex$/, '');\n  const useIndex = prop !== targetFuncName;\n  const isWrite = writeMethods.includes(targetFuncName);\n\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {\n    return;\n  }\n\n  const method = async function (storeName, ...args) {\n    // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n    const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n    let target = tx.store;\n    if (useIndex) target = target.index(args.shift()); // Must reject if op rejects.\n    // If it's a write operation, must reject if tx.done rejects.\n    // Must reject with op rejection first.\n    // Must resolve with op value.\n    // Must handle both promises (no unhandled rejections)\n\n    return (await Promise.all([target[targetFuncName](...args), isWrite && tx.done]))[0];\n  };\n\n  cachedMethods.set(prop, method);\n  return method;\n}\n\n(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)(oldTraps => ({ ...oldTraps,\n  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)\n}));\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/idb/build/esm/index.js?");

/***/ }),

/***/ "./node_modules/idb/build/esm/wrap-idb-value.js":
/*!******************************************************!*\
  !*** ./node_modules/idb/build/esm/wrap-idb-value.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"a\": () => (/* binding */ reverseTransformCache),\n/* harmony export */   \"i\": () => (/* binding */ instanceOfAny),\n/* harmony export */   \"r\": () => (/* binding */ replaceTraps),\n/* harmony export */   \"u\": () => (/* binding */ unwrap),\n/* harmony export */   \"w\": () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods; // This is a function to prevent it throwing up in node environments.\n\nfunction getIdbProxyableTypes() {\n  return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\n} // This is a function to prevent it throwing up in node environments.\n\n\nfunction getCursorAdvanceMethods() {\n  return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);\n}\n\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\n\nfunction promisifyRequest(request) {\n  const promise = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      request.removeEventListener('success', success);\n      request.removeEventListener('error', error);\n    };\n\n    const success = () => {\n      resolve(wrap(request.result));\n      unlisten();\n    };\n\n    const error = () => {\n      reject(request.error);\n      unlisten();\n    };\n\n    request.addEventListener('success', success);\n    request.addEventListener('error', error);\n  });\n  promise.then(value => {\n    // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n    // (see wrapFunction).\n    if (value instanceof IDBCursor) {\n      cursorRequestMap.set(value, request);\n    } // Catching to avoid \"Uncaught Promise exceptions\"\n\n  }).catch(() => {}); // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n  // is because we create many promises from a single IDBRequest.\n\n  reverseTransformCache.set(promise, request);\n  return promise;\n}\n\nfunction cacheDonePromiseForTransaction(tx) {\n  // Early bail if we've already created a done promise for this transaction.\n  if (transactionDoneMap.has(tx)) return;\n  const done = new Promise((resolve, reject) => {\n    const unlisten = () => {\n      tx.removeEventListener('complete', complete);\n      tx.removeEventListener('error', error);\n      tx.removeEventListener('abort', error);\n    };\n\n    const complete = () => {\n      resolve();\n      unlisten();\n    };\n\n    const error = () => {\n      reject(tx.error || new DOMException('AbortError', 'AbortError'));\n      unlisten();\n    };\n\n    tx.addEventListener('complete', complete);\n    tx.addEventListener('error', error);\n    tx.addEventListener('abort', error);\n  }); // Cache it for later retrieval.\n\n  transactionDoneMap.set(tx, done);\n}\n\nlet idbProxyTraps = {\n  get(target, prop, receiver) {\n    if (target instanceof IDBTransaction) {\n      // Special handling for transaction.done.\n      if (prop === 'done') return transactionDoneMap.get(target); // Polyfill for objectStoreNames because of Edge.\n\n      if (prop === 'objectStoreNames') {\n        return target.objectStoreNames || transactionStoreNamesMap.get(target);\n      } // Make tx.store return the only store in the transaction, or undefined if there are many.\n\n\n      if (prop === 'store') {\n        return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n      }\n    } // Else transform whatever we get back.\n\n\n    return wrap(target[prop]);\n  },\n\n  set(target, prop, value) {\n    target[prop] = value;\n    return true;\n  },\n\n  has(target, prop) {\n    if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) {\n      return true;\n    }\n\n    return prop in target;\n  }\n\n};\n\nfunction replaceTraps(callback) {\n  idbProxyTraps = callback(idbProxyTraps);\n}\n\nfunction wrapFunction(func) {\n  // Due to expected object equality (which is enforced by the caching in `wrap`), we\n  // only create one new func per func.\n  // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n  if (func === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)) {\n    return function (storeNames, ...args) {\n      const tx = func.call(unwrap(this), storeNames, ...args);\n      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n      return wrap(tx);\n    };\n  } // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n  // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n  // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n  // with real promises, so each advance methods returns a new promise for the cursor object, or\n  // undefined if the end of the cursor has been reached.\n\n\n  if (getCursorAdvanceMethods().includes(func)) {\n    return function (...args) {\n      // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n      // the original object.\n      func.apply(unwrap(this), args);\n      return wrap(cursorRequestMap.get(this));\n    };\n  }\n\n  return function (...args) {\n    // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n    // the original object.\n    return wrap(func.apply(unwrap(this), args));\n  };\n}\n\nfunction transformCachableValue(value) {\n  if (typeof value === 'function') return wrapFunction(value); // This doesn't return, it just creates a 'done' promise for the transaction,\n  // which is later returned for transaction.done (see idbObjectHandler).\n\n  if (value instanceof IDBTransaction) cacheDonePromiseForTransaction(value);\n  if (instanceOfAny(value, getIdbProxyableTypes())) return new Proxy(value, idbProxyTraps); // Return the same value back if we're not going to transform it.\n\n  return value;\n}\n\nfunction wrap(value) {\n  // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n  // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n  if (value instanceof IDBRequest) return promisifyRequest(value); // If we've already transformed this value before, reuse the transformed value.\n  // This is faster, but it also provides object equality.\n\n  if (transformCache.has(value)) return transformCache.get(value);\n  const newValue = transformCachableValue(value); // Not all types are transformed.\n  // These may be primitive types, so they can't be WeakMap keys.\n\n  if (newValue !== value) {\n    transformCache.set(value, newValue);\n    reverseTransformCache.set(newValue, value);\n  }\n\n  return newValue;\n}\n\nconst unwrap = value => reverseTransformCache.get(value);\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/idb/build/esm/wrap-idb-value.js?");

/***/ }),

/***/ "./node_modules/workbox-cacheable-response/CacheableResponse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/workbox-cacheable-response/CacheableResponse.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheableResponse\": () => (/* binding */ CacheableResponse)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-cacheable-response/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_4__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n/**\n * This class allows you to set up rules determining what\n * status codes and/or headers need to be present in order for a\n * [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response)\n * to be considered cacheable.\n *\n * @memberof module:workbox-cacheable-response\n */\n\nclass CacheableResponse {\n  /**\n   * To construct a new CacheableResponse instance you must provide at least\n   * one of the `config` properties.\n   *\n   * If both `statuses` and `headers` are specified, then both conditions must\n   * be met for the `Response` to be considered cacheable.\n   *\n   * @param {Object} config\n   * @param {Array<number>} [config.statuses] One or more status codes that a\n   * `Response` can have and be considered cacheable.\n   * @param {Object<string,string>} [config.headers] A mapping of header names\n   * and expected values that a `Response` can have and be considered cacheable.\n   * If multiple headers are provided, only one needs to be present.\n   */\n  constructor(config = {}) {\n    if (false) {}\n\n    this._statuses = config.statuses;\n    this._headers = config.headers;\n  }\n  /**\n   * Checks a response to see whether it's cacheable or not, based on this\n   * object's configuration.\n   *\n   * @param {Response} response The response whose cacheability is being\n   * checked.\n   * @return {boolean} `true` if the `Response` is cacheable, and `false`\n   * otherwise.\n   */\n\n\n  isResponseCacheable(response) {\n    if (false) {}\n\n    let cacheable = true;\n\n    if (this._statuses) {\n      cacheable = this._statuses.includes(response.status);\n    }\n\n    if (this._headers && cacheable) {\n      cacheable = Object.keys(this._headers).some(headerName => {\n        return response.headers.get(headerName) === this._headers[headerName];\n      });\n    }\n\n    if (false) {}\n\n    return cacheable;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-cacheable-response/CacheableResponse.js?");

/***/ }),

/***/ "./node_modules/workbox-cacheable-response/CacheableResponsePlugin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/workbox-cacheable-response/CacheableResponsePlugin.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheableResponsePlugin\": () => (/* binding */ CacheableResponsePlugin)\n/* harmony export */ });\n/* harmony import */ var _CacheableResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CacheableResponse.js */ \"./node_modules/workbox-cacheable-response/CacheableResponse.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-cacheable-response/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * A class implementing the `cacheWillUpdate` lifecycle callback. This makes it\n * easier to add in cacheability checks to requests made via Workbox's built-in\n * strategies.\n *\n * @memberof module:workbox-cacheable-response\n */\n\nclass CacheableResponsePlugin {\n  /**\n   * To construct a new CacheableResponsePlugin instance you must provide at\n   * least one of the `config` properties.\n   *\n   * If both `statuses` and `headers` are specified, then both conditions must\n   * be met for the `Response` to be considered cacheable.\n   *\n   * @param {Object} config\n   * @param {Array<number>} [config.statuses] One or more status codes that a\n   * `Response` can have and be considered cacheable.\n   * @param {Object<string,string>} [config.headers] A mapping of header names\n   * and expected values that a `Response` can have and be considered cacheable.\n   * If multiple headers are provided, only one needs to be present.\n   */\n  constructor(config) {\n    /**\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     * @private\n     */\n    this.cacheWillUpdate = async ({\n      response\n    }) => {\n      if (this._cacheableResponse.isResponseCacheable(response)) {\n        return response;\n      }\n\n      return null;\n    };\n\n    this._cacheableResponse = new _CacheableResponse_js__WEBPACK_IMPORTED_MODULE_0__.CacheableResponse(config);\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-cacheable-response/CacheableResponsePlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-cacheable-response/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-cacheable-response/_version.js ***!
  \*************************************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:cacheable-response:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-cacheable-response/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-cacheable-response/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-cacheable-response/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheableResponse\": () => (/* reexport safe */ _CacheableResponse_js__WEBPACK_IMPORTED_MODULE_0__.CacheableResponse),\n/* harmony export */   \"CacheableResponsePlugin\": () => (/* reexport safe */ _CacheableResponsePlugin_js__WEBPACK_IMPORTED_MODULE_1__.CacheableResponsePlugin)\n/* harmony export */ });\n/* harmony import */ var _CacheableResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CacheableResponse.js */ \"./node_modules/workbox-cacheable-response/CacheableResponse.js\");\n/* harmony import */ var _CacheableResponsePlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CacheableResponsePlugin.js */ \"./node_modules/workbox-cacheable-response/CacheableResponsePlugin.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-cacheable-response/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * @module workbox-cacheable-response\n */\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-cacheable-response/index.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private.js":
/*!***********************************************!*\
  !*** ./node_modules/workbox-core/_private.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* reexport safe */ _private_assert_js__WEBPACK_IMPORTED_MODULE_0__.assert),\n/* harmony export */   \"cacheMatchIgnoreParams\": () => (/* reexport safe */ _private_cacheMatchIgnoreParams_js__WEBPACK_IMPORTED_MODULE_2__.cacheMatchIgnoreParams),\n/* harmony export */   \"cacheNames\": () => (/* reexport safe */ _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__.cacheNames),\n/* harmony export */   \"canConstructReadableStream\": () => (/* reexport safe */ _private_canConstructReadableStream_js__WEBPACK_IMPORTED_MODULE_3__.canConstructReadableStream),\n/* harmony export */   \"canConstructResponseFromBodyStream\": () => (/* reexport safe */ _private_canConstructResponseFromBodyStream_js__WEBPACK_IMPORTED_MODULE_4__.canConstructResponseFromBodyStream),\n/* harmony export */   \"dontWaitFor\": () => (/* reexport safe */ _private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_5__.dontWaitFor),\n/* harmony export */   \"Deferred\": () => (/* reexport safe */ _private_Deferred_js__WEBPACK_IMPORTED_MODULE_6__.Deferred),\n/* harmony export */   \"executeQuotaErrorCallbacks\": () => (/* reexport safe */ _private_executeQuotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_7__.executeQuotaErrorCallbacks),\n/* harmony export */   \"getFriendlyURL\": () => (/* reexport safe */ _private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_8__.getFriendlyURL),\n/* harmony export */   \"logger\": () => (/* reexport safe */ _private_logger_js__WEBPACK_IMPORTED_MODULE_9__.logger),\n/* harmony export */   \"resultingClientExists\": () => (/* reexport safe */ _private_resultingClientExists_js__WEBPACK_IMPORTED_MODULE_10__.resultingClientExists),\n/* harmony export */   \"timeout\": () => (/* reexport safe */ _private_timeout_js__WEBPACK_IMPORTED_MODULE_11__.timeout),\n/* harmony export */   \"waitUntil\": () => (/* reexport safe */ _private_waitUntil_js__WEBPACK_IMPORTED_MODULE_12__.waitUntil),\n/* harmony export */   \"WorkboxError\": () => (/* reexport safe */ _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_13__.WorkboxError)\n/* harmony export */ });\n/* harmony import */ var _private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var _private_cacheMatchIgnoreParams_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_private/cacheMatchIgnoreParams.js */ \"./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js\");\n/* harmony import */ var _private_canConstructReadableStream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_private/canConstructReadableStream.js */ \"./node_modules/workbox-core/_private/canConstructReadableStream.js\");\n/* harmony import */ var _private_canConstructResponseFromBodyStream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_private/canConstructResponseFromBodyStream.js */ \"./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js\");\n/* harmony import */ var _private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_private/dontWaitFor.js */ \"./node_modules/workbox-core/_private/dontWaitFor.js\");\n/* harmony import */ var _private_Deferred_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_private/Deferred.js */ \"./node_modules/workbox-core/_private/Deferred.js\");\n/* harmony import */ var _private_executeQuotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_private/executeQuotaErrorCallbacks.js */ \"./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js\");\n/* harmony import */ var _private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var _private_logger_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _private_resultingClientExists_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_private/resultingClientExists.js */ \"./node_modules/workbox-core/_private/resultingClientExists.js\");\n/* harmony import */ var _private_timeout_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_private/timeout.js */ \"./node_modules/workbox-core/_private/timeout.js\");\n/* harmony import */ var _private_waitUntil_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_private/waitUntil.js */ \"./node_modules/workbox-core/_private/waitUntil.js\");\n/* harmony import */ var _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_14__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n// We either expose defaults or we expose every named export.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/Deferred.js":
/*!********************************************************!*\
  !*** ./node_modules/workbox-core/_private/Deferred.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Deferred\": () => (/* binding */ Deferred)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\n\nclass Deferred {\n  /**\n   * Creates a promise and exposes its resolve and reject functions as methods.\n   */\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/Deferred.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/WorkboxError.js":
/*!************************************************************!*\
  !*** ./node_modules/workbox-core/_private/WorkboxError.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WorkboxError\": () => (/* binding */ WorkboxError)\n/* harmony export */ });\n/* harmony import */ var _models_messages_messageGenerator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/messages/messageGenerator.js */ \"./node_modules/workbox-core/models/messages/messageGenerator.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Workbox errors should be thrown with this class.\n * This allows use to ensure the type easily in tests,\n * helps developers identify errors from workbox\n * easily and allows use to optimise error\n * messages correctly.\n *\n * @private\n */\n\nclass WorkboxError extends Error {\n  /**\n   *\n   * @param {string} errorCode The error code that\n   * identifies this particular error.\n   * @param {Object=} details Any relevant arguments\n   * that will help developers identify issues should\n   * be added as a key on the context object.\n   */\n  constructor(errorCode, details) {\n    const message = (0,_models_messages_messageGenerator_js__WEBPACK_IMPORTED_MODULE_0__.messageGenerator)(errorCode, details);\n    super(message);\n    this.name = errorCode;\n    this.details = details;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/WorkboxError.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/assert.js":
/*!******************************************************!*\
  !*** ./node_modules/workbox-core/_private/assert.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assert\": () => (/* binding */ finalAssertExports)\n/* harmony export */ });\n/* harmony import */ var _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/*\n * This method throws if the supplied value is not an array.\n * The destructed values are required to produce a meaningful error for users.\n * The destructed and restructured object is so it's clear what is\n * needed.\n */\n\nconst isArray = (value, details) => {\n  if (!Array.isArray(value)) {\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('not-an-array', details);\n  }\n};\n\nconst hasMethod = (object, expectedMethod, details) => {\n  const type = typeof object[expectedMethod];\n\n  if (type !== 'function') {\n    details['expectedMethod'] = expectedMethod;\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('missing-a-method', details);\n  }\n};\n\nconst isType = (object, expectedType, details) => {\n  if (typeof object !== expectedType) {\n    details['expectedType'] = expectedType;\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('incorrect-type', details);\n  }\n};\n\nconst isInstance = (object, // Need the general type to do the check later.\n// eslint-disable-next-line @typescript-eslint/ban-types\nexpectedClass, details) => {\n  if (!(object instanceof expectedClass)) {\n    details['expectedClassName'] = expectedClass.name;\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('incorrect-class', details);\n  }\n};\n\nconst isOneOf = (value, validValues, details) => {\n  if (!validValues.includes(value)) {\n    details['validValueDescription'] = `Valid values are ${JSON.stringify(validValues)}.`;\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('invalid-value', details);\n  }\n};\n\nconst isArrayOfClass = (value, // Need general type to do check later.\nexpectedClass, // eslint-disable-line\ndetails) => {\n  const error = new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('not-array-of-class', details);\n\n  if (!Array.isArray(value)) {\n    throw error;\n  }\n\n  for (const item of value) {\n    if (!(item instanceof expectedClass)) {\n      throw error;\n    }\n  }\n};\n\nconst finalAssertExports =  true ? null : 0;\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/assert.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js":
/*!**********************************************************************!*\
  !*** ./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cacheMatchIgnoreParams\": () => (/* binding */ cacheMatchIgnoreParams)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nfunction stripParams(fullURL, ignoreParams) {\n  const strippedURL = new URL(fullURL);\n\n  for (const param of ignoreParams) {\n    strippedURL.searchParams.delete(param);\n  }\n\n  return strippedURL.href;\n}\n/**\n * Matches an item in the cache, ignoring specific URL params. This is similar\n * to the `ignoreSearch` option, but it allows you to ignore just specific\n * params (while continuing to match on the others).\n *\n * @private\n * @param {Cache} cache\n * @param {Request} request\n * @param {Object} matchOptions\n * @param {Array<string>} ignoreParams\n * @return {Promise<Response|undefined>}\n */\n\n\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n  const strippedRequestURL = stripParams(request.url, ignoreParams); // If the request doesn't include any ignored params, match as normal.\n\n  if (request.url === strippedRequestURL) {\n    return cache.match(request, matchOptions);\n  } // Otherwise, match by comparing keys\n\n\n  const keysOptions = Object.assign(Object.assign({}, matchOptions), {\n    ignoreSearch: true\n  });\n  const cacheKeys = await cache.keys(request, keysOptions);\n\n  for (const cacheKey of cacheKeys) {\n    const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n\n    if (strippedRequestURL === strippedCacheKeyURL) {\n      return cache.match(cacheKey, matchOptions);\n    }\n  }\n\n  return;\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/cacheNames.js":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-core/_private/cacheNames.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cacheNames\": () => (/* binding */ cacheNames)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst _cacheNameDetails = {\n  googleAnalytics: 'googleAnalytics',\n  precache: 'precache-v2',\n  prefix: 'workbox',\n  runtime: 'runtime',\n  suffix: typeof registration !== 'undefined' ? registration.scope : ''\n};\n\nconst _createCacheName = cacheName => {\n  return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value && value.length > 0).join('-');\n};\n\nconst eachCacheNameDetail = fn => {\n  for (const key of Object.keys(_cacheNameDetails)) {\n    fn(key);\n  }\n};\n\nconst cacheNames = {\n  updateDetails: details => {\n    eachCacheNameDetail(key => {\n      if (typeof details[key] === 'string') {\n        _cacheNameDetails[key] = details[key];\n      }\n    });\n  },\n  getGoogleAnalyticsName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n  },\n  getPrecacheName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.precache);\n  },\n  getPrefix: () => {\n    return _cacheNameDetails.prefix;\n  },\n  getRuntimeName: userCacheName => {\n    return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n  },\n  getSuffix: () => {\n    return _cacheNameDetails.suffix;\n  }\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/cacheNames.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/canConstructReadableStream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/workbox-core/_private/canConstructReadableStream.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canConstructReadableStream\": () => (/* binding */ canConstructReadableStream)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n * object.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `ReadableStream`, `false` otherwise.\n *\n * @private\n */\n\nfunction canConstructReadableStream() {\n  if (supportStatus === undefined) {\n    // See https://github.com/GoogleChrome/workbox/issues/1473\n    try {\n      new ReadableStream({\n        start() {}\n\n      });\n      supportStatus = true;\n    } catch (error) {\n      supportStatus = false;\n    }\n  }\n\n  return supportStatus;\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/canConstructReadableStream.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canConstructResponseFromBodyStream\": () => (/* binding */ canConstructResponseFromBodyStream)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nlet supportStatus;\n/**\n * A utility function that determines whether the current browser supports\n * constructing a new `Response` from a `response.body` stream.\n *\n * @return {boolean} `true`, if the current browser can successfully\n *     construct a `Response` from a `response.body` stream, `false` otherwise.\n *\n * @private\n */\n\nfunction canConstructResponseFromBodyStream() {\n  if (supportStatus === undefined) {\n    const testResponse = new Response('');\n\n    if ('body' in testResponse) {\n      try {\n        new Response(testResponse.body);\n        supportStatus = true;\n      } catch (error) {\n        supportStatus = false;\n      }\n    }\n\n    supportStatus = false;\n  }\n\n  return supportStatus;\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/dontWaitFor.js":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-core/_private/dontWaitFor.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dontWaitFor\": () => (/* binding */ dontWaitFor)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\n\nfunction dontWaitFor(promise) {\n  // Effective no-op.\n  void promise.then(() => {});\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/dontWaitFor.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"executeQuotaErrorCallbacks\": () => (/* binding */ executeQuotaErrorCallbacks)\n/* harmony export */ });\n/* harmony import */ var _private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _models_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../models/quotaErrorCallbacks.js */ \"./node_modules/workbox-core/models/quotaErrorCallbacks.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * Runs all of the callback functions, one at a time sequentially, in the order\n * in which they were registered.\n *\n * @memberof module:workbox-core\n * @private\n */\n\nasync function executeQuotaErrorCallbacks() {\n  if (false) {}\n\n  for (const callback of _models_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_1__.quotaErrorCallbacks) {\n    await callback();\n\n    if (false) {}\n  }\n\n  if (false) {}\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/getFriendlyURL.js":
/*!**************************************************************!*\
  !*** ./node_modules/workbox-core/_private/getFriendlyURL.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getFriendlyURL\": () => (/* binding */ getFriendlyURL)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst getFriendlyURL = url => {\n  const urlObj = new URL(String(url), location.href); // See https://github.com/GoogleChrome/workbox/issues/2323\n  // We want to include everything, except for the origin if it's same-origin.\n\n  return urlObj.href.replace(new RegExp(`^${location.origin}`), '');\n};\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/getFriendlyURL.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/logger.js":
/*!******************************************************!*\
  !*** ./node_modules/workbox-core/_private/logger.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"logger\": () => (/* binding */ logger)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst logger =  true ? null : 0;\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/logger.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/resultingClientExists.js":
/*!*********************************************************************!*\
  !*** ./node_modules/workbox-core/_private/resultingClientExists.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resultingClientExists\": () => (/* binding */ resultingClientExists)\n/* harmony export */ });\n/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timeout.js */ \"./node_modules/workbox-core/_private/timeout.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst MAX_RETRY_TIME = 2000;\n/**\n * Returns a promise that resolves to a window client matching the passed\n * `resultingClientId`. For browsers that don't support `resultingClientId`\n * or if waiting for the resulting client to apper takes too long, resolve to\n * `undefined`.\n *\n * @param {string} [resultingClientId]\n * @return {Promise<Client|undefined>}\n * @private\n */\n\nasync function resultingClientExists(resultingClientId) {\n  if (!resultingClientId) {\n    return;\n  }\n\n  let existingWindows = await self.clients.matchAll({\n    type: 'window'\n  });\n  const existingWindowIds = new Set(existingWindows.map(w => w.id));\n  let resultingWindow;\n  const startTime = performance.now(); // Only wait up to `MAX_RETRY_TIME` to find a matching client.\n\n  while (performance.now() - startTime < MAX_RETRY_TIME) {\n    existingWindows = await self.clients.matchAll({\n      type: 'window'\n    });\n    resultingWindow = existingWindows.find(w => {\n      if (resultingClientId) {\n        // If we have a `resultingClientId`, we can match on that.\n        return w.id === resultingClientId;\n      } else {\n        // Otherwise match on finding a window not in `existingWindowIds`.\n        return !existingWindowIds.has(w.id);\n      }\n    });\n\n    if (resultingWindow) {\n      break;\n    } // Sleep for 100ms and retry.\n\n\n    await (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.timeout)(100);\n  }\n\n  return resultingWindow;\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/resultingClientExists.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/timeout.js":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-core/_private/timeout.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"timeout\": () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Returns a promise that resolves and the passed number of milliseconds.\n * This utility is an async/await-friendly version of `setTimeout`.\n *\n * @param {number} ms\n * @return {Promise}\n * @private\n */\n\nfunction timeout(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/timeout.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_private/waitUntil.js":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-core/_private/waitUntil.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"waitUntil\": () => (/* binding */ waitUntil)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2020 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A utility method that makes it easier to use `event.waitUntil` with\n * async functions and return the result.\n *\n * @param {ExtendableEvent} event\n * @param {Function} asyncFn\n * @return {Function}\n * @private\n */\n\nfunction waitUntil(event, asyncFn) {\n  const returnPromise = asyncFn();\n  event.waitUntil(returnPromise);\n  return returnPromise;\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_private/waitUntil.js?");

/***/ }),

/***/ "./node_modules/workbox-core/_version.js":
/*!***********************************************!*\
  !*** ./node_modules/workbox-core/_version.js ***!
  \***********************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:core:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-core/cacheNames.js":
/*!*************************************************!*\
  !*** ./node_modules/workbox-core/cacheNames.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cacheNames\": () => (/* binding */ cacheNames)\n/* harmony export */ });\n/* harmony import */ var _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Get the current cache names and prefix/suffix used by Workbox.\n *\n * `cacheNames.precache` is used for precached assets,\n * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n * store `analytics.js`, and `cacheNames.runtime` is used for everything else.\n *\n * `cacheNames.prefix` can be used to retrieve just the current prefix value.\n * `cacheNames.suffix` can be used to retrieve just the current suffix value.\n *\n * @return {Object} An object with `precache`, `runtime`, `prefix`, and\n *     `googleAnalytics` properties.\n *\n * @memberof module:workbox-core\n */\n\nconst cacheNames = {\n  get googleAnalytics() {\n    return _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getGoogleAnalyticsName();\n  },\n\n  get precache() {\n    return _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getPrecacheName();\n  },\n\n  get prefix() {\n    return _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getPrefix();\n  },\n\n  get runtime() {\n    return _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getRuntimeName();\n  },\n\n  get suffix() {\n    return _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getSuffix();\n  }\n\n};\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/cacheNames.js?");

/***/ }),

/***/ "./node_modules/workbox-core/clientsClaim.js":
/*!***************************************************!*\
  !*** ./node_modules/workbox-core/clientsClaim.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clientsClaim\": () => (/* binding */ clientsClaim)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Claim any currently available clients once the service worker\n * becomes active. This is normally used in conjunction with `skipWaiting()`.\n *\n * @memberof module:workbox-core\n */\n\nfunction clientsClaim() {\n  self.addEventListener('activate', () => self.clients.claim());\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/clientsClaim.js?");

/***/ }),

/***/ "./node_modules/workbox-core/copyResponse.js":
/*!***************************************************!*\
  !*** ./node_modules/workbox-core/copyResponse.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"copyResponse\": () => (/* binding */ copyResponse)\n/* harmony export */ });\n/* harmony import */ var _private_canConstructResponseFromBodyStream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/canConstructResponseFromBodyStream.js */ \"./node_modules/workbox-core/_private/canConstructResponseFromBodyStream.js\");\n/* harmony import */ var _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * Allows developers to copy a response and modify its `headers`, `status`,\n * or `statusText` values (the values settable via a\n * [`ResponseInit`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response/Response#Syntax}\n * object in the constructor).\n * To modify these values, pass a function as the second argument. That\n * function will be invoked with a single object with the response properties\n * `{headers, status, statusText}`. The return value of this function will\n * be used as the `ResponseInit` for the new `Response`. To change the values\n * either modify the passed parameter(s) and return it, or return a totally\n * new object.\n *\n * This method is intentionally limited to same-origin responses, regardless of\n * whether CORS was used or not.\n *\n * @param {Response} response\n * @param {Function} modifier\n * @memberof module:workbox-core\n */\n\nasync function copyResponse(response, modifier) {\n  let origin = null; // If response.url isn't set, assume it's cross-origin and keep origin null.\n\n  if (response.url) {\n    const responseURL = new URL(response.url);\n    origin = responseURL.origin;\n  }\n\n  if (origin !== self.location.origin) {\n    throw new _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__.WorkboxError('cross-origin-copy-response', {\n      origin\n    });\n  }\n\n  const clonedResponse = response.clone(); // Create a fresh `ResponseInit` object by cloning the headers.\n\n  const responseInit = {\n    headers: new Headers(clonedResponse.headers),\n    status: clonedResponse.status,\n    statusText: clonedResponse.statusText\n  }; // Apply any user modifications.\n\n  const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit; // Create the new response from the body stream and `ResponseInit`\n  // modifications. Note: not all browsers support the Response.body stream,\n  // so fall back to reading the entire body into memory as a blob.\n\n  const body = (0,_private_canConstructResponseFromBodyStream_js__WEBPACK_IMPORTED_MODULE_0__.canConstructResponseFromBodyStream)() ? clonedResponse.body : await clonedResponse.blob();\n  return new Response(body, modifiedResponseInit);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/copyResponse.js?");

/***/ }),

/***/ "./node_modules/workbox-core/index.js":
/*!********************************************!*\
  !*** ./node_modules/workbox-core/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_private\": () => (/* reexport module object */ _private_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   \"cacheNames\": () => (/* reexport safe */ _cacheNames_js__WEBPACK_IMPORTED_MODULE_2__.cacheNames),\n/* harmony export */   \"clientsClaim\": () => (/* reexport safe */ _clientsClaim_js__WEBPACK_IMPORTED_MODULE_4__.clientsClaim),\n/* harmony export */   \"copyResponse\": () => (/* reexport safe */ _copyResponse_js__WEBPACK_IMPORTED_MODULE_3__.copyResponse),\n/* harmony export */   \"registerQuotaErrorCallback\": () => (/* reexport safe */ _registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_0__.registerQuotaErrorCallback),\n/* harmony export */   \"setCacheNameDetails\": () => (/* reexport safe */ _setCacheNameDetails_js__WEBPACK_IMPORTED_MODULE_5__.setCacheNameDetails),\n/* harmony export */   \"skipWaiting\": () => (/* reexport safe */ _skipWaiting_js__WEBPACK_IMPORTED_MODULE_6__.skipWaiting)\n/* harmony export */ });\n/* harmony import */ var _registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registerQuotaErrorCallback.js */ \"./node_modules/workbox-core/registerQuotaErrorCallback.js\");\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_private.js */ \"./node_modules/workbox-core/_private.js\");\n/* harmony import */ var _cacheNames_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cacheNames.js */ \"./node_modules/workbox-core/cacheNames.js\");\n/* harmony import */ var _copyResponse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./copyResponse.js */ \"./node_modules/workbox-core/copyResponse.js\");\n/* harmony import */ var _clientsClaim_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clientsClaim.js */ \"./node_modules/workbox-core/clientsClaim.js\");\n/* harmony import */ var _setCacheNameDetails_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./setCacheNameDetails.js */ \"./node_modules/workbox-core/setCacheNameDetails.js\");\n/* harmony import */ var _skipWaiting_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./skipWaiting.js */ \"./node_modules/workbox-core/skipWaiting.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types.js */ \"./node_modules/workbox-core/types.js\");\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n/**\n * All of the Workbox service worker libraries use workbox-core for shared\n * code as well as setting default values that need to be shared (like cache\n * names).\n *\n * @module workbox-core\n */\n\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/index.js?");

/***/ }),

/***/ "./node_modules/workbox-core/models/messages/messageGenerator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/workbox-core/models/messages/messageGenerator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"messageGenerator\": () => (/* binding */ messageGenerator)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/workbox-core/models/messages/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\nconst fallback = (code, ...args) => {\n  let msg = code;\n\n  if (args.length > 0) {\n    msg += ` :: ${JSON.stringify(args)}`;\n  }\n\n  return msg;\n};\n\nconst generatorFunction = (code, details = {}) => {\n  const message = _messages_js__WEBPACK_IMPORTED_MODULE_0__.messages[code];\n\n  if (!message) {\n    throw new Error(`Unable to find message for code '${code}'.`);\n  }\n\n  return message(details);\n};\n\nconst messageGenerator =  true ? fallback : 0;\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/models/messages/messageGenerator.js?");

/***/ }),

/***/ "./node_modules/workbox-core/models/messages/messages.js":
/*!***************************************************************!*\
  !*** ./node_modules/workbox-core/models/messages/messages.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"messages\": () => (/* binding */ messages)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst messages = {\n  'invalid-value': ({\n    paramName,\n    validValueDescription,\n    value\n  }) => {\n    if (!paramName || !validValueDescription) {\n      throw new Error(`Unexpected input to 'invalid-value' error.`);\n    }\n\n    return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n  },\n  'not-an-array': ({\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    if (!moduleName || !className || !funcName || !paramName) {\n      throw new Error(`Unexpected input to 'not-an-array' error.`);\n    }\n\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n  },\n  'incorrect-type': ({\n    expectedType,\n    paramName,\n    moduleName,\n    className,\n    funcName\n  }) => {\n    if (!expectedType || !paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-type' error.`);\n    }\n\n    const classNameStr = className ? `${className}.` : '';\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n  },\n  'incorrect-class': ({\n    expectedClassName,\n    paramName,\n    moduleName,\n    className,\n    funcName,\n    isReturnValueProblem\n  }) => {\n    if (!expectedClassName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'incorrect-class' error.`);\n    }\n\n    const classNameStr = className ? `${className}.` : '';\n\n    if (isReturnValueProblem) {\n      return `The return value from ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    }\n\n    return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n  },\n  'missing-a-method': ({\n    expectedMethod,\n    paramName,\n    moduleName,\n    className,\n    funcName\n  }) => {\n    if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n      throw new Error(`Unexpected input to 'missing-a-method' error.`);\n    }\n\n    return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n  },\n  'add-to-cache-list-unexpected-type': ({\n    entry\n  }) => {\n    return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n  },\n  'add-to-cache-list-conflicting-entries': ({\n    firstEntry,\n    secondEntry\n  }) => {\n    if (!firstEntry || !secondEntry) {\n      throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n    }\n\n    return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${firstEntry} but different revision details. Workbox is ` + `unable to cache and version the asset correctly. Please remove one ` + `of the entries.`;\n  },\n  'plugin-error-request-will-fetch': ({\n    thrownErrorMessage\n  }) => {\n    if (!thrownErrorMessage) {\n      throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n    }\n\n    return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownErrorMessage}'.`;\n  },\n  'invalid-cache-name': ({\n    cacheNameId,\n    value\n  }) => {\n    if (!cacheNameId) {\n      throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n    }\n\n    return `You must provide a name containing at least one character for ` + `setCacheDetails({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n  },\n  'unregister-route-but-not-found-with-method': ({\n    method\n  }) => {\n    if (!method) {\n      throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n    }\n\n    return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n  },\n  'unregister-route-route-not-registered': () => {\n    return `The route you're trying to unregister was not previously ` + `registered.`;\n  },\n  'queue-replay-failed': ({\n    name\n  }) => {\n    return `Replaying the background sync queue '${name}' failed.`;\n  },\n  'duplicate-queue-name': ({\n    name\n  }) => {\n    return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n  },\n  'expired-test-without-max-age': ({\n    methodName,\n    paramName\n  }) => {\n    return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n  },\n  'unsupported-route-type': ({\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n  },\n  'not-array-of-class': ({\n    value,\n    expectedClass,\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n  },\n  'max-entries-or-age-required': ({\n    moduleName,\n    className,\n    funcName\n  }) => {\n    return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n  },\n  'statuses-or-headers-required': ({\n    moduleName,\n    className,\n    funcName\n  }) => {\n    return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n  },\n  'invalid-string': ({\n    moduleName,\n    funcName,\n    paramName\n  }) => {\n    if (!paramName || !moduleName || !funcName) {\n      throw new Error(`Unexpected input to 'invalid-string' error.`);\n    }\n\n    return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${funcName}() for ` + `more info.`;\n  },\n  'channel-name-required': () => {\n    return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n  },\n  'invalid-responses-are-same-args': () => {\n    return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n  },\n  'expire-custom-caches-only': () => {\n    return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n  },\n  'unit-must-be-bytes': ({\n    normalizedRangeHeader\n  }) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n    }\n\n    return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n  },\n  'single-range-only': ({\n    normalizedRangeHeader\n  }) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'single-range-only' error.`);\n    }\n\n    return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n  },\n  'invalid-range-values': ({\n    normalizedRangeHeader\n  }) => {\n    if (!normalizedRangeHeader) {\n      throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n    }\n\n    return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n  },\n  'no-range-header': () => {\n    return `No Range header was found in the Request provided.`;\n  },\n  'range-not-satisfiable': ({\n    size,\n    start,\n    end\n  }) => {\n    return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n  },\n  'attempt-to-cache-non-get-request': ({\n    url,\n    method\n  }) => {\n    return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n  },\n  'cache-put-with-no-response': ({\n    url\n  }) => {\n    return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n  },\n  'no-response': ({\n    url,\n    error\n  }) => {\n    let message = `The strategy could not generate a response for '${url}'.`;\n\n    if (error) {\n      message += ` The underlying error is ${error}.`;\n    }\n\n    return message;\n  },\n  'bad-precaching-response': ({\n    url,\n    status\n  }) => {\n    return `The precaching request for '${url}' failed` + (status ? ` with an HTTP status of ${status}.` : `.`);\n  },\n  'non-precached-url': ({\n    url\n  }) => {\n    return `createHandlerBoundToURL('${url}') was called, but that URL is ` + `not precached. Please pass in a URL that is precached instead.`;\n  },\n  'add-to-cache-list-conflicting-integrities': ({\n    url\n  }) => {\n    return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had the URL ` + `${url} with different integrity values. Please remove one of them.`;\n  },\n  'missing-precache-entry': ({\n    cacheName,\n    url\n  }) => {\n    return `Unable to find a precached response in ${cacheName} for ${url}.`;\n  },\n  'cross-origin-copy-response': ({\n    origin\n  }) => {\n    return `workbox-core.copyResponse() can only be used with same-origin ` + `responses. It was passed a response with origin ${origin}.`;\n  }\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/models/messages/messages.js?");

/***/ }),

/***/ "./node_modules/workbox-core/models/quotaErrorCallbacks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/workbox-core/models/quotaErrorCallbacks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"quotaErrorCallbacks\": () => (/* binding */ quotaErrorCallbacks)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n // Callbacks to be executed whenever there's a quota error.\n// Can't change Function type right now.\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst quotaErrorCallbacks = new Set();\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/models/quotaErrorCallbacks.js?");

/***/ }),

/***/ "./node_modules/workbox-core/registerQuotaErrorCallback.js":
/*!*****************************************************************!*\
  !*** ./node_modules/workbox-core/registerQuotaErrorCallback.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"registerQuotaErrorCallback\": () => (/* binding */ registerQuotaErrorCallback)\n/* harmony export */ });\n/* harmony import */ var _private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _private_assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var _models_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/quotaErrorCallbacks.js */ \"./node_modules/workbox-core/models/quotaErrorCallbacks.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * Adds a function to the set of quotaErrorCallbacks that will be executed if\n * there's a quota error.\n *\n * @param {Function} callback\n * @memberof module:workbox-core\n */\n// Can't change Function type\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction registerQuotaErrorCallback(callback) {\n  if (false) {}\n\n  _models_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_2__.quotaErrorCallbacks.add(callback);\n\n  if (false) {}\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/registerQuotaErrorCallback.js?");

/***/ }),

/***/ "./node_modules/workbox-core/setCacheNameDetails.js":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-core/setCacheNameDetails.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setCacheNameDetails\": () => (/* binding */ setCacheNameDetails)\n/* harmony export */ });\n/* harmony import */ var _private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var _private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * Modifies the default cache names used by the Workbox packages.\n * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n *\n * @param {Object} details\n * @param {Object} [details.prefix] The string to add to the beginning of\n *     the precache and runtime cache names.\n * @param {Object} [details.suffix] The string to add to the end of\n *     the precache and runtime cache names.\n * @param {Object} [details.precache] The cache name to use for precache\n *     caching.\n * @param {Object} [details.runtime] The cache name to use for runtime caching.\n * @param {Object} [details.googleAnalytics] The cache name to use for\n *     `workbox-google-analytics` caching.\n *\n * @memberof module:workbox-core\n */\n\nfunction setCacheNameDetails(details) {\n  if (false) {}\n\n  _private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__.cacheNames.updateDetails(details);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/setCacheNameDetails.js?");

/***/ }),

/***/ "./node_modules/workbox-core/skipWaiting.js":
/*!**************************************************!*\
  !*** ./node_modules/workbox-core/skipWaiting.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"skipWaiting\": () => (/* binding */ skipWaiting)\n/* harmony export */ });\n/* harmony import */ var _private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * This method is deprecated, and will be removed in Workbox v7.\n *\n * Calling self.skipWaiting() is equivalent, and should be used instead.\n *\n * @memberof module:workbox-core\n */\n\nfunction skipWaiting() {\n  // Just call self.skipWaiting() directly.\n  // See https://github.com/GoogleChrome/workbox/issues/2525\n  if (false) {}\n\n  void self.skipWaiting();\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/skipWaiting.js?");

/***/ }),

/***/ "./node_modules/workbox-core/types.js":
/*!********************************************!*\
  !*** ./node_modules/workbox-core/types.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-core/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/types.js?");

/***/ }),

/***/ "./node_modules/workbox-expiration/CacheExpiration.js":
/*!************************************************************!*\
  !*** ./node_modules/workbox-expiration/CacheExpiration.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheExpiration\": () => (/* binding */ CacheExpiration)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/dontWaitFor.js */ \"./node_modules/workbox-core/_private/dontWaitFor.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _models_CacheTimestampsModel_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/CacheTimestampsModel.js */ \"./node_modules/workbox-expiration/models/CacheTimestampsModel.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-expiration/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_5__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof module:workbox-expiration\n */\n\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   */\n  constructor(cacheName, config = {}) {\n    this._isRunning = false;\n    this._rerunRequested = false;\n\n    if (false) {}\n\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._matchOptions = config.matchOptions;\n    this._cacheName = cacheName;\n    this._timestampModel = new _models_CacheTimestampsModel_js__WEBPACK_IMPORTED_MODULE_4__.CacheTimestampsModel(cacheName);\n  }\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n\n\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n\n    this._isRunning = true;\n    const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n    const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries); // Delete URLs from the cache\n\n    const cache = await self.caches.open(this._cacheName);\n\n    for (const url of urlsExpired) {\n      await cache.delete(url, this._matchOptions);\n    }\n\n    if (false) {}\n\n    this._isRunning = false;\n\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      (0,workbox_core_private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_1__.dontWaitFor)(this.expireEntries());\n    }\n  }\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n\n\n  async updateTimestamp(url) {\n    if (false) {}\n\n    await this._timestampModel.setTimestamp(url, Date.now());\n  }\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n\n\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      if (false) {}\n\n      return false;\n    } else {\n      const timestamp = await this._timestampModel.getTimestamp(url);\n      const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n      return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n  }\n  /**\n   * Removes the IndexedDB object store used to keep track of cache expiration\n   * metadata.\n   */\n\n\n  async delete() {\n    // Make sure we don't attempt another rerun if we're called in the middle of\n    // a cache expiration.\n    this._rerunRequested = false;\n    await this._timestampModel.expireEntries(Infinity); // Expires all.\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/CacheExpiration.js?");

/***/ }),

/***/ "./node_modules/workbox-expiration/ExpirationPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-expiration/ExpirationPlugin.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ExpirationPlugin\": () => (/* binding */ ExpirationPlugin)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var workbox_core_private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/dontWaitFor.js */ \"./node_modules/workbox-core/_private/dontWaitFor.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/registerQuotaErrorCallback.js */ \"./node_modules/workbox-core/registerQuotaErrorCallback.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _CacheExpiration_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./CacheExpiration.js */ \"./node_modules/workbox-expiration/CacheExpiration.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-expiration/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_8__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the associated cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof module:workbox-expiration\n */\n\nclass ExpirationPlugin {\n  /**\n   * @param {ExpirationPluginOptions} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor(config = {}) {\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n    this.cachedResponseWillBeUsed = async ({\n      event,\n      request,\n      cacheName,\n      cachedResponse\n    }) => {\n      if (!cachedResponse) {\n        return null;\n      }\n\n      const isFresh = this._isResponseDateFresh(cachedResponse); // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      (0,workbox_core_private_dontWaitFor_js__WEBPACK_IMPORTED_MODULE_2__.dontWaitFor)(cacheExpiration.expireEntries()); // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          if (false) {}\n        }\n      }\n\n      return isFresh ? cachedResponse : null;\n    };\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n\n\n    this.cacheDidUpdate = async ({\n      cacheName,\n      request\n    }) => {\n      if (false) {}\n\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    };\n\n    if (false) {}\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n\n    if (config.purgeOnQuotaError) {\n      (0,workbox_core_registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_5__.registerQuotaErrorCallback)(() => this.deleteCacheAndMetadata());\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n\n\n  _getCacheExpiration(cacheName) {\n    if (cacheName === workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__.cacheNames.getRuntimeName()) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_6__.WorkboxError('expire-custom-caches-only');\n    }\n\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n\n    if (!cacheExpiration) {\n      cacheExpiration = new _CacheExpiration_js__WEBPACK_IMPORTED_MODULE_7__.CacheExpiration(cacheName, this._config);\n\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n\n    return cacheExpiration;\n  }\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n\n\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    } // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n\n\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    } // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n\n\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n  }\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number|null}\n   *\n   * @private\n   */\n\n\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime(); // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n\n\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await self.caches.delete(cacheName);\n      await cacheExpiration.delete();\n    } // Reset this._cacheExpirations to its initial state.\n\n\n    this._cacheExpirations = new Map();\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/ExpirationPlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-expiration/_version.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-expiration/_version.js ***!
  \*****************************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:expiration:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-expiration/index.js":
/*!**************************************************!*\
  !*** ./node_modules/workbox-expiration/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheExpiration\": () => (/* reexport safe */ _CacheExpiration_js__WEBPACK_IMPORTED_MODULE_0__.CacheExpiration),\n/* harmony export */   \"ExpirationPlugin\": () => (/* reexport safe */ _ExpirationPlugin_js__WEBPACK_IMPORTED_MODULE_1__.ExpirationPlugin)\n/* harmony export */ });\n/* harmony import */ var _CacheExpiration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CacheExpiration.js */ \"./node_modules/workbox-expiration/CacheExpiration.js\");\n/* harmony import */ var _ExpirationPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExpirationPlugin.js */ \"./node_modules/workbox-expiration/ExpirationPlugin.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-expiration/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * @module workbox-expiration\n */\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/index.js?");

/***/ }),

/***/ "./node_modules/workbox-expiration/models/CacheTimestampsModel.js":
/*!************************************************************************!*\
  !*** ./node_modules/workbox-expiration/models/CacheTimestampsModel.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheTimestampsModel\": () => (/* binding */ CacheTimestampsModel)\n/* harmony export */ });\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! idb */ \"./node_modules/idb/build/esm/index.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-expiration/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nconst DB_NAME = 'workbox-expiration';\nconst CACHE_OBJECT_STORE = 'cache-entries';\n\nconst normalizeURL = unNormalizedUrl => {\n  const url = new URL(unNormalizedUrl, location.href);\n  url.hash = '';\n  return url.href;\n};\n/**\n * Returns the timestamp model.\n *\n * @private\n */\n\n\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._db = null;\n    this._cacheName = cacheName;\n  }\n  /**\n   * Performs an upgrade of indexedDB.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n\n\n  _upgradeDb(db) {\n    // TODO(philipwalton): EdgeHTML doesn't support arrays as a keyPath, so we\n    // have to use the `id` keyPath here and create our own values (a\n    // concatenation of `url + cacheName`) instead of simply using\n    // `keyPath: ['url', 'cacheName']`, which is supported in other browsers.\n    const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n      keyPath: 'id'\n    }); // TODO(philipwalton): once we don't have to support EdgeHTML, we can\n    // create a single index with the keyPath `['cacheName', 'timestamp']`\n    // instead of doing both these indexes.\n\n    objStore.createIndex('cacheName', 'cacheName', {\n      unique: false\n    });\n    objStore.createIndex('timestamp', 'timestamp', {\n      unique: false\n    });\n  }\n  /**\n   * Performs an upgrade of indexedDB and deletes deprecated DBs.\n   *\n   * @param {IDBPDatabase<CacheDbSchema>} db\n   *\n   * @private\n   */\n\n\n  _upgradeDbAndDeleteOldDbs(db) {\n    this._upgradeDb(db);\n\n    if (this._cacheName) {\n      void (0,idb__WEBPACK_IMPORTED_MODULE_0__.deleteDB)(this._cacheName);\n    }\n  }\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n\n\n  async setTimestamp(url, timestamp) {\n    url = normalizeURL(url);\n    const entry = {\n      url,\n      timestamp,\n      cacheName: this._cacheName,\n      // Creating an ID from the URL and cache name won't be necessary once\n      // Edge switches to Chromium and all browsers we support work with\n      // array keyPaths.\n      id: this._getId(url)\n    };\n    const db = await this.getDb();\n    const tx = db.transaction(CACHE_OBJECT_STORE, 'readwrite', {\n      durability: 'relaxed'\n    });\n    await tx.store.put(entry);\n    await tx.done;\n  }\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number | undefined}\n   *\n   * @private\n   */\n\n\n  async getTimestamp(url) {\n    const db = await this.getDb();\n    const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n    return entry === null || entry === void 0 ? void 0 : entry.timestamp;\n  }\n  /**\n   * Iterates through all the entries in the object store (from newest to\n   * oldest) and removes entries once either `maxCount` is reached or the\n   * entry's timestamp is less than `minTimestamp`.\n   *\n   * @param {number} minTimestamp\n   * @param {number} maxCount\n   * @return {Array<string>}\n   *\n   * @private\n   */\n\n\n  async expireEntries(minTimestamp, maxCount) {\n    const db = await this.getDb();\n    let cursor = await db.transaction(CACHE_OBJECT_STORE).store.index('timestamp').openCursor(null, 'prev');\n    const entriesToDelete = [];\n    let entriesNotDeletedCount = 0;\n\n    while (cursor) {\n      const result = cursor.value; // TODO(philipwalton): once we can use a multi-key index, we\n      // won't have to check `cacheName` here.\n\n      if (result.cacheName === this._cacheName) {\n        // Delete an entry if it's older than the max age or\n        // if we already have the max number allowed.\n        if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n          // TODO(philipwalton): we should be able to delete the\n          // entry right here, but doing so causes an iteration\n          // bug in Safari stable (fixed in TP). Instead we can\n          // store the keys of the entries to delete, and then\n          // delete the separate transactions.\n          // https://github.com/GoogleChrome/workbox/issues/1978\n          // cursor.delete();\n          // We only need to return the URL, not the whole entry.\n          entriesToDelete.push(cursor.value);\n        } else {\n          entriesNotDeletedCount++;\n        }\n      }\n\n      cursor = await cursor.continue();\n    } // TODO(philipwalton): once the Safari bug in the following issue is fixed,\n    // we should be able to remove this loop and do the entry deletion in the\n    // cursor loop above:\n    // https://github.com/GoogleChrome/workbox/issues/1978\n\n\n    const urlsDeleted = [];\n\n    for (const entry of entriesToDelete) {\n      await db.delete(CACHE_OBJECT_STORE, entry.id);\n      urlsDeleted.push(entry.url);\n    }\n\n    return urlsDeleted;\n  }\n  /**\n   * Takes a URL and returns an ID that will be unique in the object store.\n   *\n   * @param {string} url\n   * @return {string}\n   *\n   * @private\n   */\n\n\n  _getId(url) {\n    // Creating an ID from the URL and cache name won't be necessary once\n    // Edge switches to Chromium and all browsers we support work with\n    // array keyPaths.\n    return this._cacheName + '|' + normalizeURL(url);\n  }\n  /**\n    * Returns an open connection to the database.\n    *\n    * @private\n    */\n\n\n  async getDb() {\n    if (!this._db) {\n      this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_0__.openDB)(DB_NAME, 1, {\n        upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n      });\n    }\n\n    return this._db;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/models/CacheTimestampsModel.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/PrecacheController.js":
/*!***************************************************************!*\
  !*** ./node_modules/workbox-precaching/PrecacheController.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheController\": () => (/* binding */ PrecacheController)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var workbox_core_private_waitUntil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/waitUntil.js */ \"./node_modules/workbox-core/_private/waitUntil.js\");\n/* harmony import */ var _utils_createCacheKey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/createCacheKey.js */ \"./node_modules/workbox-precaching/utils/createCacheKey.js\");\n/* harmony import */ var _utils_PrecacheInstallReportPlugin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/PrecacheInstallReportPlugin.js */ \"./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js\");\n/* harmony import */ var _utils_PrecacheCacheKeyPlugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/PrecacheCacheKeyPlugin.js */ \"./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js\");\n/* harmony import */ var _utils_printCleanupDetails_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/printCleanupDetails.js */ \"./node_modules/workbox-precaching/utils/printCleanupDetails.js\");\n/* harmony import */ var _utils_printInstallDetails_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/printInstallDetails.js */ \"./node_modules/workbox-precaching/utils/printInstallDetails.js\");\n/* harmony import */ var _PrecacheStrategy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PrecacheStrategy.js */ \"./node_modules/workbox-precaching/PrecacheStrategy.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_11__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] The cache to use for precaching.\n   * @param {string} [options.plugins] Plugins to use when precaching as well\n   * as responding to fetch events for precached assets.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor({\n    cacheName,\n    plugins = [],\n    fallbackToNetwork = true\n  } = {}) {\n    this._urlsToCacheKeys = new Map();\n    this._urlsToCacheModes = new Map();\n    this._cacheKeysToIntegrities = new Map();\n    this._strategy = new _PrecacheStrategy_js__WEBPACK_IMPORTED_MODULE_10__.PrecacheStrategy({\n      cacheName: workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__.cacheNames.getPrecacheName(cacheName),\n      plugins: [...plugins, new _utils_PrecacheCacheKeyPlugin_js__WEBPACK_IMPORTED_MODULE_7__.PrecacheCacheKeyPlugin({\n        precacheController: this\n      })],\n      fallbackToNetwork\n    }); // Bind the install and activate methods to the instance.\n\n    this.install = this.install.bind(this);\n    this.activate = this.activate.bind(this);\n  }\n  /**\n   * @type {module:workbox-precaching.PrecacheStrategy} The strategy created by this controller and\n   * used to cache assets and respond to fetch events.\n   */\n\n\n  get strategy() {\n    return this._strategy;\n  }\n  /**\n   * Adds items to the precache list, removing any duplicates and\n   * stores the files in the\n   * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n   * worker installs.\n   *\n   * This method can be called multiple times.\n   *\n   * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n   */\n\n\n  precache(entries) {\n    this.addToCacheList(entries);\n\n    if (!this._installAndActiveListenersAdded) {\n      self.addEventListener('install', this.install);\n      self.addEventListener('activate', this.activate);\n      this._installAndActiveListenersAdded = true;\n    }\n  }\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>} entries\n   *     Array of entries to precache.\n   */\n\n\n  addToCacheList(entries) {\n    if (false) {}\n\n    const urlsToWarnAbout = [];\n\n    for (const entry of entries) {\n      // See https://github.com/GoogleChrome/workbox/issues/2259\n      if (typeof entry === 'string') {\n        urlsToWarnAbout.push(entry);\n      } else if (entry && entry.revision === undefined) {\n        urlsToWarnAbout.push(entry.url);\n      }\n\n      const {\n        cacheKey,\n        url\n      } = (0,_utils_createCacheKey_js__WEBPACK_IMPORTED_MODULE_5__.createCacheKey)(entry);\n      const cacheMode = typeof entry !== 'string' && entry.revision ? 'reload' : 'default';\n\n      if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n        throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__.WorkboxError('add-to-cache-list-conflicting-entries', {\n          firstEntry: this._urlsToCacheKeys.get(url),\n          secondEntry: cacheKey\n        });\n      }\n\n      if (typeof entry !== 'string' && entry.integrity) {\n        if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n          throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__.WorkboxError('add-to-cache-list-conflicting-integrities', {\n            url\n          });\n        }\n\n        this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n      }\n\n      this._urlsToCacheKeys.set(url, cacheKey);\n\n      this._urlsToCacheModes.set(url, cacheMode);\n\n      if (urlsToWarnAbout.length > 0) {\n        const warningMessage = `Workbox is precaching URLs without revision ` + `info: ${urlsToWarnAbout.join(', ')}\\nThis is generally NOT safe. ` + `Learn more at https://bit.ly/wb-precache`;\n\n        if (true) {\n          // Use console directly to display this warning without bloating\n          // bundle sizes by pulling in all of the logger codebase in prod.\n          console.warn(warningMessage);\n        } else {}\n      }\n    }\n  }\n  /**\n   * Precaches new and updated assets. Call this method from the service worker\n   * install event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<module:workbox-precaching.InstallResult>}\n   */\n\n\n  install(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return (0,workbox_core_private_waitUntil_js__WEBPACK_IMPORTED_MODULE_4__.waitUntil)(event, async () => {\n      const installReportPlugin = new _utils_PrecacheInstallReportPlugin_js__WEBPACK_IMPORTED_MODULE_6__.PrecacheInstallReportPlugin();\n      this.strategy.plugins.push(installReportPlugin); // Cache entries one at a time.\n      // See https://github.com/GoogleChrome/workbox/issues/2528\n\n      for (const [url, cacheKey] of this._urlsToCacheKeys) {\n        const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n\n        const cacheMode = this._urlsToCacheModes.get(url);\n\n        const request = new Request(url, {\n          integrity,\n          cache: cacheMode,\n          credentials: 'same-origin'\n        });\n        await Promise.all(this.strategy.handleAll({\n          params: {\n            cacheKey\n          },\n          request,\n          event\n        }));\n      }\n\n      const {\n        updatedURLs,\n        notUpdatedURLs\n      } = installReportPlugin;\n\n      if (false) {}\n\n      return {\n        updatedURLs,\n        notUpdatedURLs\n      };\n    });\n  }\n  /**\n   * Deletes assets that are no longer present in the current precache manifest.\n   * Call this method from the service worker activate event.\n   *\n   * Note: this method calls `event.waitUntil()` for you, so you do not need\n   * to call it yourself in your event handlers.\n   *\n   * @param {ExtendableEvent} event\n   * @return {Promise<module:workbox-precaching.CleanupResult>}\n   */\n\n\n  activate(event) {\n    // waitUntil returns Promise<any>\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return (0,workbox_core_private_waitUntil_js__WEBPACK_IMPORTED_MODULE_4__.waitUntil)(event, async () => {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      const currentlyCachedRequests = await cache.keys();\n      const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n      const deletedURLs = [];\n\n      for (const request of currentlyCachedRequests) {\n        if (!expectedCacheKeys.has(request.url)) {\n          await cache.delete(request);\n          deletedURLs.push(request.url);\n        }\n      }\n\n      if (false) {}\n\n      return {\n        deletedURLs\n      };\n    });\n  }\n  /**\n   * Returns a mapping of a precached URL to the corresponding cache key, taking\n   * into account the revision information for the URL.\n   *\n   * @return {Map<string, string>} A URL to cache key mapping.\n   */\n\n\n  getURLsToCacheKeys() {\n    return this._urlsToCacheKeys;\n  }\n  /**\n   * Returns a list of all the URLs that have been precached by the current\n   * service worker.\n   *\n   * @return {Array<string>} The precached URLs.\n   */\n\n\n  getCachedURLs() {\n    return [...this._urlsToCacheKeys.keys()];\n  }\n  /**\n   * Returns the cache key used for storing a given URL. If that URL is\n   * unversioned, like `/index.html', then the cache key will be the original\n   * URL with a search parameter appended to it.\n   *\n   * @param {string} url A URL whose cache key you want to look up.\n   * @return {string} The versioned URL that corresponds to a cache key\n   * for the original URL, or undefined if that URL isn't precached.\n   */\n\n\n  getCacheKeyForURL(url) {\n    const urlObject = new URL(url, location.href);\n    return this._urlsToCacheKeys.get(urlObject.href);\n  }\n  /**\n   * @param {string} url A cache key whose SRI you want to look up.\n   * @return {string} The subresource integrity associated with the cache key,\n   * or undefined if it's not set.\n   */\n\n\n  getIntegrityForCacheKey(cacheKey) {\n    return this._cacheKeysToIntegrities.get(cacheKey);\n  }\n  /**\n   * This acts as a drop-in replacement for\n   * [`cache.match()`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match)\n   * with the following differences:\n   *\n   * - It knows what the name of the precache is, and only checks in that cache.\n   * - It allows you to pass in an \"original\" URL without versioning parameters,\n   * and it will automatically look up the correct cache key for the currently\n   * active revision of that URL.\n   *\n   * E.g., `matchPrecache('index.html')` will find the correct precached\n   * response for the currently active service worker, even if the actual cache\n   * key is `'/index.html?__WB_REVISION__=1234abcd'`.\n   *\n   * @param {string|Request} request The key (without revisioning parameters)\n   * to look up in the precache.\n   * @return {Promise<Response|undefined>}\n   */\n\n\n  async matchPrecache(request) {\n    const url = request instanceof Request ? request.url : request;\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (cacheKey) {\n      const cache = await self.caches.open(this.strategy.cacheName);\n      return cache.match(cacheKey);\n    }\n\n    return undefined;\n  }\n  /**\n   * Returns a function that looks up `url` in the precache (taking into\n   * account revision information), and returns the corresponding `Response`.\n   *\n   * @param {string} url The precached URL which will be used to lookup the\n   * `Response`.\n   * @return {module:workbox-routing~handlerCallback}\n   */\n\n\n  createHandlerBoundToURL(url) {\n    const cacheKey = this.getCacheKeyForURL(url);\n\n    if (!cacheKey) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__.WorkboxError('non-precached-url', {\n        url\n      });\n    }\n\n    return options => {\n      options.request = new Request(url);\n      options.params = Object.assign({\n        cacheKey\n      }, options.params);\n      return this.strategy.handle(options);\n    };\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/PrecacheController.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/PrecacheFallbackPlugin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/workbox-precaching/PrecacheFallbackPlugin.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheFallbackPlugin\": () => (/* binding */ PrecacheFallbackPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * `PrecacheFallbackPlugin` allows you to specify an \"offline fallback\"\n * response to be used when a given strategy is unable to generate a response.\n *\n * It does this by intercepting the `handlerDidError` plugin callback\n * and returning a precached response, taking the expected revision parameter\n * into account automatically.\n *\n * Unless you explicitly pass in a `PrecacheController` instance to the\n * constructor, the default instance will be used. Generally speaking, most\n * developers will end up using the default.\n *\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheFallbackPlugin {\n  /**\n   * Constructs a new PrecacheFallbackPlugin with the associated fallbackURL.\n   *\n   * @param {Object} config\n   * @param {string} config.fallbackURL A precached URL to use as the fallback\n   *     if the associated strategy can't generate a response.\n   * @param {PrecacheController} [config.precacheController] An optional\n   *     PrecacheController instance. If not provided, the default\n   *     PrecacheController will be used.\n   */\n  constructor({\n    fallbackURL,\n    precacheController\n  }) {\n    /**\n     * @return {Promise<Response>} The precache response for the fallback URL.\n     *\n     * @private\n     */\n    this.handlerDidError = () => this._precacheController.matchPrecache(this._fallbackURL);\n\n    this._fallbackURL = fallbackURL;\n    this._precacheController = precacheController || (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/PrecacheFallbackPlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/PrecacheRoute.js":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-precaching/PrecacheRoute.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheRoute\": () => (/* binding */ PrecacheRoute)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var workbox_routing_Route_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-routing/Route.js */ \"./node_modules/workbox-routing/Route.js\");\n/* harmony import */ var _utils_generateURLVariations_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/generateURLVariations.js */ \"./node_modules/workbox-precaching/utils/generateURLVariations.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_4__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n/**\n * A subclass of [Route]{@link module:workbox-routing.Route} that takes a\n * [PrecacheController]{@link module:workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof module:workbox-precaching\n * @extends module:workbox-routing.Route\n */\n\nclass PrecacheRoute extends workbox_routing_Route_js__WEBPACK_IMPORTED_MODULE_2__.Route {\n  /**\n   * @param {PrecacheController} precacheController A `PrecacheController`\n   * instance used to both match requests and respond to fetch events.\n   * @param {Object} [options] Options to control how requests are matched\n   * against the list of precached URLs.\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {module:workbox-precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URLs that should be checked for precache matches.\n   */\n  constructor(precacheController, options) {\n    const match = ({\n      request\n    }) => {\n      const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n\n      for (const possibleURL of (0,_utils_generateURLVariations_js__WEBPACK_IMPORTED_MODULE_3__.generateURLVariations)(request.url, options)) {\n        const cacheKey = urlsToCacheKeys.get(possibleURL);\n\n        if (cacheKey) {\n          const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n          return {\n            cacheKey,\n            integrity\n          };\n        }\n      }\n\n      if (false) {}\n\n      return;\n    };\n\n    super(match, precacheController.strategy);\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/PrecacheRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/PrecacheStrategy.js":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-precaching/PrecacheStrategy.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheStrategy\": () => (/* binding */ PrecacheStrategy)\n/* harmony export */ });\n/* harmony import */ var workbox_core_copyResponse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/copyResponse.js */ \"./node_modules/workbox-core/copyResponse.js\");\n/* harmony import */ var workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var workbox_strategies_Strategy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-strategies/Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_6__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * A [Strategy]{@link module:workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * [PrecacheController]{@link module:workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-precaching\n */\n\nclass PrecacheStrategy extends workbox_strategies_Strategy_js__WEBPACK_IMPORTED_MODULE_5__.Strategy {\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor(options = {}) {\n    options.cacheName = workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_1__.cacheNames.getPrecacheName(options.cacheName);\n    super(options);\n    this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true; // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n\n    this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  async _handle(request, handler) {\n    const response = await handler.cacheMatch(request);\n\n    if (response) {\n      return response;\n    } // If this is an `install` event for an entry that isn't already cached,\n    // then populate the cache.\n\n\n    if (handler.event && handler.event.type === 'install') {\n      return await this._handleInstall(request, handler);\n    } // Getting here means something went wrong. An entry that should have been\n    // precached wasn't found in the cache.\n\n\n    return await this._handleFetch(request, handler);\n  }\n\n  async _handleFetch(request, handler) {\n    let response;\n    const params = handler.params || {}; // Fall back to the network if we're configured to do so.\n\n    if (this._fallbackToNetwork) {\n      if (false) {}\n\n      const integrityInManifest = params.integrity;\n      const integrityInRequest = request.integrity;\n      const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n      response = await handler.fetch(new Request(request, {\n        integrity: integrityInRequest || integrityInManifest\n      })); // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n      // that the response matches the precache manifest's expectations,\n      // and there's either a) no integrity property in the incoming request\n      // or b) there is an integrity, and it matches the precache manifest.\n      // See https://github.com/GoogleChrome/workbox/issues/2858\n\n      if (integrityInManifest && noIntegrityConflict) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n\n        const wasCached = await handler.cachePut(request, response.clone());\n\n        if (false) {}\n      }\n    } else {\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_4__.WorkboxError('missing-precache-entry', {\n        cacheName: this.cacheName,\n        url: request.url\n      });\n    }\n\n    if (false) {}\n\n    return response;\n  }\n\n  async _handleInstall(request, handler) {\n    this._useDefaultCacheabilityPluginIfNeeded();\n\n    const response = await handler.fetch(request); // Make sure we defer cachePut() until after we know the response\n    // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n\n    const wasCached = await handler.cachePut(request, response.clone());\n\n    if (!wasCached) {\n      // Throwing here will lead to the `install` handler failing, which\n      // we want to do if *any* of the responses aren't safe to cache.\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_4__.WorkboxError('bad-precaching-response', {\n        url: request.url,\n        status: response.status\n      });\n    }\n\n    return response;\n  }\n  /**\n   * This method is complex, as there a number of things to account for:\n   *\n   * The `plugins` array can be set at construction, and/or it might be added to\n   * to at any time before the strategy is used.\n   *\n   * At the time the strategy is used (i.e. during an `install` event), there\n   * needs to be at least one plugin that implements `cacheWillUpdate` in the\n   * array, other than `copyRedirectedCacheableResponsesPlugin`.\n   *\n   * - If this method is called and there are no suitable `cacheWillUpdate`\n   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n   *\n   * - If this method is called and there is exactly one `cacheWillUpdate`, then\n   * we don't have to do anything (this might be a previously added\n   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n   *\n   * - If this method is called and there is more than one `cacheWillUpdate`,\n   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n   * we need to remove it. (This situation is unlikely, but it could happen if\n   * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n   * and then later on after manually adding a custom `cacheWillUpdate`.)\n   *\n   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n   *\n   * @private\n   */\n\n\n  _useDefaultCacheabilityPluginIfNeeded() {\n    let defaultPluginIndex = null;\n    let cacheWillUpdatePluginCount = 0;\n\n    for (const [index, plugin] of this.plugins.entries()) {\n      // Ignore the copy redirected plugin when determining what to do.\n      if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n        continue;\n      } // Save the default plugin's index, in case it needs to be removed.\n\n\n      if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n        defaultPluginIndex = index;\n      }\n\n      if (plugin.cacheWillUpdate) {\n        cacheWillUpdatePluginCount++;\n      }\n    }\n\n    if (cacheWillUpdatePluginCount === 0) {\n      this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n    } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n      // Only remove the default plugin; multiple custom plugins are allowed.\n      this.plugins.splice(defaultPluginIndex, 1);\n    } // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n\n  }\n\n}\n\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  async cacheWillUpdate({\n    response\n  }) {\n    if (!response || response.status >= 400) {\n      return null;\n    }\n\n    return response;\n  }\n\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  async cacheWillUpdate({\n    response\n  }) {\n    return response.redirected ? await (0,workbox_core_copyResponse_js__WEBPACK_IMPORTED_MODULE_0__.copyResponse)(response) : response;\n  }\n\n};\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/PrecacheStrategy.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/_version.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-precaching/_version.js ***!
  \*****************************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:precaching:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/addPlugins.js":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-precaching/addPlugins.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addPlugins\": () => (/* binding */ addPlugins)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Adds plugins to the precaching strategy.\n *\n * @param {Array<Object>} plugins\n *\n * @memberof module:workbox-precaching\n */\n\nfunction addPlugins(plugins) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  precacheController.strategy.plugins.push(...plugins);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/addPlugins.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/addRoute.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-precaching/addRoute.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addRoute\": () => (/* binding */ addRoute)\n/* harmony export */ });\n/* harmony import */ var workbox_routing_registerRoute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-routing/registerRoute.js */ \"./node_modules/workbox-routing/registerRoute.js\");\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _PrecacheRoute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PrecacheRoute.js */ \"./node_modules/workbox-precaching/PrecacheRoute.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} [options] See\n * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.\n *\n * @memberof module:workbox-precaching\n */\n\nfunction addRoute(options) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_1__.getOrCreatePrecacheController)();\n  const precacheRoute = new _PrecacheRoute_js__WEBPACK_IMPORTED_MODULE_2__.PrecacheRoute(precacheController, options);\n  (0,workbox_routing_registerRoute_js__WEBPACK_IMPORTED_MODULE_0__.registerRoute)(precacheRoute);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/addRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/cleanupOutdatedCaches.js":
/*!******************************************************************!*\
  !*** ./node_modules/workbox-precaching/cleanupOutdatedCaches.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cleanupOutdatedCaches\": () => (/* binding */ cleanupOutdatedCaches)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _utils_deleteOutdatedCaches_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/deleteOutdatedCaches.js */ \"./node_modules/workbox-precaching/utils/deleteOutdatedCaches.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * Adds an `activate` event listener which will clean up incompatible\n * precaches that were created by older versions of Workbox.\n *\n * @memberof module:workbox-precaching\n */\n\nfunction cleanupOutdatedCaches() {\n  // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n  self.addEventListener('activate', event => {\n    const cacheName = workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getPrecacheName();\n    event.waitUntil((0,_utils_deleteOutdatedCaches_js__WEBPACK_IMPORTED_MODULE_2__.deleteOutdatedCaches)(cacheName).then(cachesDeleted => {\n      if (false) {}\n    }));\n  });\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/cleanupOutdatedCaches.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/createHandlerBoundToURL.js":
/*!********************************************************************!*\
  !*** ./node_modules/workbox-precaching/createHandlerBoundToURL.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createHandlerBoundToURL\": () => (/* binding */ createHandlerBoundToURL)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Helper function that calls\n * {@link PrecacheController#createHandlerBoundToURL} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call the\n * {@link PrecacheController#createHandlerBoundToURL} on that instance,\n * instead of using this function.\n *\n * @param {string} url The precached URL which will be used to lookup the\n * `Response`.\n * @param {boolean} [fallbackToNetwork=true] Whether to attempt to get the\n * response from the network if there's a precache miss.\n * @return {module:workbox-routing~handlerCallback}\n *\n * @memberof module:workbox-precaching\n */\n\nfunction createHandlerBoundToURL(url) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  return precacheController.createHandlerBoundToURL(url);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/createHandlerBoundToURL.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/getCacheKeyForURL.js":
/*!**************************************************************!*\
  !*** ./node_modules/workbox-precaching/getCacheKeyForURL.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCacheKeyForURL\": () => (/* binding */ getCacheKeyForURL)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Takes in a URL, and returns the corresponding URL that could be used to\n * lookup the entry in the precache.\n *\n * If a relative URL is provided, the location of the service worker file will\n * be used as the base.\n *\n * For precached entries without revision information, the cache key will be the\n * same as the original URL.\n *\n * For precached entries with revision information, the cache key will be the\n * original URL with the addition of a query parameter used for keeping track of\n * the revision info.\n *\n * @param {string} url The URL whose cache key to look up.\n * @return {string} The cache key that corresponds to that URL.\n *\n * @memberof module:workbox-precaching\n */\n\nfunction getCacheKeyForURL(url) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  return precacheController.getCacheKeyForURL(url);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/getCacheKeyForURL.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/index.js":
/*!**************************************************!*\
  !*** ./node_modules/workbox-precaching/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addPlugins\": () => (/* reexport safe */ _addPlugins_js__WEBPACK_IMPORTED_MODULE_0__.addPlugins),\n/* harmony export */   \"addRoute\": () => (/* reexport safe */ _addRoute_js__WEBPACK_IMPORTED_MODULE_1__.addRoute),\n/* harmony export */   \"cleanupOutdatedCaches\": () => (/* reexport safe */ _cleanupOutdatedCaches_js__WEBPACK_IMPORTED_MODULE_2__.cleanupOutdatedCaches),\n/* harmony export */   \"createHandlerBoundToURL\": () => (/* reexport safe */ _createHandlerBoundToURL_js__WEBPACK_IMPORTED_MODULE_3__.createHandlerBoundToURL),\n/* harmony export */   \"getCacheKeyForURL\": () => (/* reexport safe */ _getCacheKeyForURL_js__WEBPACK_IMPORTED_MODULE_4__.getCacheKeyForURL),\n/* harmony export */   \"matchPrecache\": () => (/* reexport safe */ _matchPrecache_js__WEBPACK_IMPORTED_MODULE_5__.matchPrecache),\n/* harmony export */   \"precache\": () => (/* reexport safe */ _precache_js__WEBPACK_IMPORTED_MODULE_6__.precache),\n/* harmony export */   \"precacheAndRoute\": () => (/* reexport safe */ _precacheAndRoute_js__WEBPACK_IMPORTED_MODULE_7__.precacheAndRoute),\n/* harmony export */   \"PrecacheController\": () => (/* reexport safe */ _PrecacheController_js__WEBPACK_IMPORTED_MODULE_8__.PrecacheController),\n/* harmony export */   \"PrecacheRoute\": () => (/* reexport safe */ _PrecacheRoute_js__WEBPACK_IMPORTED_MODULE_9__.PrecacheRoute),\n/* harmony export */   \"PrecacheStrategy\": () => (/* reexport safe */ _PrecacheStrategy_js__WEBPACK_IMPORTED_MODULE_10__.PrecacheStrategy),\n/* harmony export */   \"PrecacheFallbackPlugin\": () => (/* reexport safe */ _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_11__.PrecacheFallbackPlugin)\n/* harmony export */ });\n/* harmony import */ var _addPlugins_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addPlugins.js */ \"./node_modules/workbox-precaching/addPlugins.js\");\n/* harmony import */ var _addRoute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addRoute.js */ \"./node_modules/workbox-precaching/addRoute.js\");\n/* harmony import */ var _cleanupOutdatedCaches_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cleanupOutdatedCaches.js */ \"./node_modules/workbox-precaching/cleanupOutdatedCaches.js\");\n/* harmony import */ var _createHandlerBoundToURL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createHandlerBoundToURL.js */ \"./node_modules/workbox-precaching/createHandlerBoundToURL.js\");\n/* harmony import */ var _getCacheKeyForURL_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getCacheKeyForURL.js */ \"./node_modules/workbox-precaching/getCacheKeyForURL.js\");\n/* harmony import */ var _matchPrecache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./matchPrecache.js */ \"./node_modules/workbox-precaching/matchPrecache.js\");\n/* harmony import */ var _precache_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./precache.js */ \"./node_modules/workbox-precaching/precache.js\");\n/* harmony import */ var _precacheAndRoute_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./precacheAndRoute.js */ \"./node_modules/workbox-precaching/precacheAndRoute.js\");\n/* harmony import */ var _PrecacheController_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./PrecacheController.js */ \"./node_modules/workbox-precaching/PrecacheController.js\");\n/* harmony import */ var _PrecacheRoute_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PrecacheRoute.js */ \"./node_modules/workbox-precaching/PrecacheRoute.js\");\n/* harmony import */ var _PrecacheStrategy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PrecacheStrategy.js */ \"./node_modules/workbox-precaching/PrecacheStrategy.js\");\n/* harmony import */ var _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./PrecacheFallbackPlugin.js */ \"./node_modules/workbox-precaching/PrecacheFallbackPlugin.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_12__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Most consumers of this module will want to use the\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}\n * method to add assets to the cache and respond to network requests with these\n * cached assets.\n *\n * If you require more control over caching and routing, you can use the\n * [PrecacheController]{@link module:workbox-precaching.PrecacheController}\n * interface.\n *\n * @module workbox-precaching\n */\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/index.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/matchPrecache.js":
/*!**********************************************************!*\
  !*** ./node_modules/workbox-precaching/matchPrecache.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"matchPrecache\": () => (/* binding */ matchPrecache)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Helper function that calls\n * {@link PrecacheController#matchPrecache} on the default\n * {@link PrecacheController} instance.\n *\n * If you are creating your own {@link PrecacheController}, then call\n * {@link PrecacheController#matchPrecache} on that instance,\n * instead of using this function.\n *\n * @param {string|Request} request The key (without revisioning parameters)\n * to look up in the precache.\n * @return {Promise<Response|undefined>}\n *\n * @memberof module:workbox-precaching\n */\n\nfunction matchPrecache(request) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  return precacheController.matchPrecache(request);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/matchPrecache.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/precache.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-precaching/precache.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"precache\": () => (/* binding */ precache)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreatePrecacheController.js */ \"./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Adds items to the precache list, removing any duplicates and\n * stores the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you.\n * It only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} [entries=[]] Array of entries to precache.\n *\n * @memberof module:workbox-precaching\n */\n\nfunction precache(entries) {\n  const precacheController = (0,_utils_getOrCreatePrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreatePrecacheController)();\n  precacheController.precache(entries);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/precache.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/precacheAndRoute.js":
/*!*************************************************************!*\
  !*** ./node_modules/workbox-precaching/precacheAndRoute.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"precacheAndRoute\": () => (/* binding */ precacheAndRoute)\n/* harmony export */ });\n/* harmony import */ var _addRoute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addRoute.js */ \"./node_modules/workbox-precaching/addRoute.js\");\n/* harmony import */ var _precache_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./precache.js */ \"./node_modules/workbox-precaching/precache.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} [options] See\n * [PrecacheRoute options]{@link module:workbox-precaching.PrecacheRoute}.\n *\n * @memberof module:workbox-precaching\n */\n\nfunction precacheAndRoute(entries, options) {\n  (0,_precache_js__WEBPACK_IMPORTED_MODULE_1__.precache)(entries);\n  (0,_addRoute_js__WEBPACK_IMPORTED_MODULE_0__.addRoute)(options);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/precacheAndRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheCacheKeyPlugin\": () => (/* binding */ PrecacheCacheKeyPlugin)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A plugin, designed to be used with PrecacheController, to translate URLs into\n * the corresponding cache key, based on the current revision info.\n *\n * @private\n */\n\nclass PrecacheCacheKeyPlugin {\n  constructor({\n    precacheController\n  }) {\n    this.cacheKeyWillBeUsed = async ({\n      request,\n      params\n    }) => {\n      // Params is type any, can't change right now.\n\n      /* eslint-disable */\n      const cacheKey = (params === null || params === void 0 ? void 0 : params.cacheKey) || this._precacheController.getCacheKeyForURL(request.url);\n      /* eslint-enable */\n\n\n      return cacheKey ? new Request(cacheKey, {\n        headers: request.headers\n      }) : request;\n    };\n\n    this._precacheController = precacheController;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/PrecacheCacheKeyPlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js":
/*!******************************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheInstallReportPlugin\": () => (/* binding */ PrecacheInstallReportPlugin)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * A plugin, designed to be used with PrecacheController, to determine the\n * of assets that were updated (or not updated) during the install event.\n *\n * @private\n */\n\nclass PrecacheInstallReportPlugin {\n  constructor() {\n    this.updatedURLs = [];\n    this.notUpdatedURLs = [];\n\n    this.handlerWillStart = async ({\n      request,\n      state\n    }) => {\n      // TODO: `state` should never be undefined...\n      if (state) {\n        state.originalRequest = request;\n      }\n    };\n\n    this.cachedResponseWillBeUsed = async ({\n      event,\n      state,\n      cachedResponse\n    }) => {\n      if (event.type === 'install') {\n        if (state && state.originalRequest && state.originalRequest instanceof Request) {\n          // TODO: `state` should never be undefined...\n          const url = state.originalRequest.url;\n\n          if (cachedResponse) {\n            this.notUpdatedURLs.push(url);\n          } else {\n            this.updatedURLs.push(url);\n          }\n        }\n      }\n\n      return cachedResponse;\n    };\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/PrecacheInstallReportPlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/createCacheKey.js":
/*!*****************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/createCacheKey.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createCacheKey\": () => (/* binding */ createCacheKey)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n // Name of the search parameter used to store revision info.\n\nconst REVISION_SEARCH_PARAM = '__WB_REVISION__';\n/**\n * Converts a manifest entry into a versioned URL suitable for precaching.\n *\n * @param {Object|string} entry\n * @return {string} A URL with versioning info.\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\nfunction createCacheKey(entry) {\n  if (!entry) {\n    throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  } // If a precache manifest entry is a string, it's assumed to be a versioned\n  // URL, like '/app.abcd1234.js'. Return as-is.\n\n\n  if (typeof entry === 'string') {\n    const urlObject = new URL(entry, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  }\n\n  const {\n    revision,\n    url\n  } = entry;\n\n  if (!url) {\n    throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_0__.WorkboxError('add-to-cache-list-unexpected-type', {\n      entry\n    });\n  } // If there's just a URL and no revision, then it's also assumed to be a\n  // versioned URL.\n\n\n  if (!revision) {\n    const urlObject = new URL(url, location.href);\n    return {\n      cacheKey: urlObject.href,\n      url: urlObject.href\n    };\n  } // Otherwise, construct a properly versioned URL using the custom Workbox\n  // search parameter along with the revision info.\n\n\n  const cacheKeyURL = new URL(url, location.href);\n  const originalURL = new URL(url, location.href);\n  cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n  return {\n    cacheKey: cacheKeyURL.href,\n    url: originalURL.href\n  };\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/createCacheKey.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/deleteOutdatedCaches.js":
/*!***********************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/deleteOutdatedCaches.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deleteOutdatedCaches\": () => (/* binding */ deleteOutdatedCaches)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst SUBSTRING_TO_FIND = '-precache-';\n/**\n * Cleans up incompatible precaches that were created by older versions of\n * Workbox, by a service worker registered under the current scope.\n *\n * This is meant to be called as part of the `activate` event.\n *\n * This should be safe to use as long as you don't include `substringToFind`\n * (defaulting to `-precache-`) in your non-precache cache names.\n *\n * @param {string} currentPrecacheName The cache name currently in use for\n * precaching. This cache won't be deleted.\n * @param {string} [substringToFind='-precache-'] Cache names which include this\n * substring will be deleted (excluding `currentPrecacheName`).\n * @return {Array<string>} A list of all the cache names that were deleted.\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND) => {\n  const cacheNames = await self.caches.keys();\n  const cacheNamesToDelete = cacheNames.filter(cacheName => {\n    return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n  });\n  await Promise.all(cacheNamesToDelete.map(cacheName => self.caches.delete(cacheName)));\n  return cacheNamesToDelete;\n};\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/deleteOutdatedCaches.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/generateURLVariations.js":
/*!************************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/generateURLVariations.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateURLVariations\": () => (/* binding */ generateURLVariations)\n/* harmony export */ });\n/* harmony import */ var _removeIgnoredSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./removeIgnoredSearchParams.js */ \"./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Generator function that yields possible variations on the original URL to\n * check, one at a time.\n *\n * @param {string} url\n * @param {Object} options\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\nfunction* generateURLVariations(url, {\n  ignoreURLParametersMatching = [/^utm_/, /^fbclid$/],\n  directoryIndex = 'index.html',\n  cleanURLs = true,\n  urlManipulation\n} = {}) {\n  const urlObject = new URL(url, location.href);\n  urlObject.hash = '';\n  yield urlObject.href;\n  const urlWithoutIgnoredParams = (0,_removeIgnoredSearchParams_js__WEBPACK_IMPORTED_MODULE_0__.removeIgnoredSearchParams)(urlObject, ignoreURLParametersMatching);\n  yield urlWithoutIgnoredParams.href;\n\n  if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith('/')) {\n    const directoryURL = new URL(urlWithoutIgnoredParams.href);\n    directoryURL.pathname += directoryIndex;\n    yield directoryURL.href;\n  }\n\n  if (cleanURLs) {\n    const cleanURL = new URL(urlWithoutIgnoredParams.href);\n    cleanURL.pathname += '.html';\n    yield cleanURL.href;\n  }\n\n  if (urlManipulation) {\n    const additionalURLs = urlManipulation({\n      url: urlObject\n    });\n\n    for (const urlToAttempt of additionalURLs) {\n      yield urlToAttempt.href;\n    }\n  }\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/generateURLVariations.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js":
/*!********************************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOrCreatePrecacheController\": () => (/* binding */ getOrCreatePrecacheController)\n/* harmony export */ });\n/* harmony import */ var _PrecacheController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PrecacheController.js */ \"./node_modules/workbox-precaching/PrecacheController.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nlet precacheController;\n/**\n * @return {PrecacheController}\n * @private\n */\n\nconst getOrCreatePrecacheController = () => {\n  if (!precacheController) {\n    precacheController = new _PrecacheController_js__WEBPACK_IMPORTED_MODULE_0__.PrecacheController();\n  }\n\n  return precacheController;\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/getOrCreatePrecacheController.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/printCleanupDetails.js":
/*!**********************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/printCleanupDetails.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"printCleanupDetails\": () => (/* binding */ printCleanupDetails)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * @param {string} groupTitle\n * @param {Array<string>} deletedURLs\n *\n * @private\n */\n\nconst logGroup = (groupTitle, deletedURLs) => {\n  workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(groupTitle);\n\n  for (const url of deletedURLs) {\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.log(url);\n  }\n\n  workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n};\n/**\n * @param {Array<string>} deletedURLs\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\n\nfunction printCleanupDetails(deletedURLs) {\n  const deletionCount = deletedURLs.length;\n\n  if (deletionCount > 0) {\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`During precaching cleanup, ` + `${deletionCount} cached ` + `request${deletionCount === 1 ? ' was' : 's were'} deleted.`);\n    logGroup('Deleted Cache Requests', deletedURLs);\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n  }\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/printCleanupDetails.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/printInstallDetails.js":
/*!**********************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/printInstallDetails.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"printInstallDetails\": () => (/* binding */ printInstallDetails)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * @param {string} groupTitle\n * @param {Array<string>} urls\n *\n * @private\n */\n\nfunction _nestedGroup(groupTitle, urls) {\n  if (urls.length === 0) {\n    return;\n  }\n\n  workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(groupTitle);\n\n  for (const url of urls) {\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.log(url);\n  }\n\n  workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n}\n/**\n * @param {Array<string>} urlsToPrecache\n * @param {Array<string>} urlsAlreadyPrecached\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\n\nfunction printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n  const precachedCount = urlsToPrecache.length;\n  const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n\n  if (precachedCount || alreadyPrecachedCount) {\n    let message = `Precaching ${precachedCount} file${precachedCount === 1 ? '' : 's'}.`;\n\n    if (alreadyPrecachedCount > 0) {\n      message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? ' is' : 's are'} already cached.`;\n    }\n\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(message);\n\n    _nestedGroup(`View newly precached URLs.`, urlsToPrecache);\n\n    _nestedGroup(`View previously precached URLs.`, urlsAlreadyPrecached);\n\n    workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n  }\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/printInstallDetails.js?");

/***/ }),

/***/ "./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"removeIgnoredSearchParams\": () => (/* binding */ removeIgnoredSearchParams)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-precaching/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * Removes any URL search parameters that should be ignored.\n *\n * @param {URL} urlObject The original URL.\n * @param {Array<RegExp>} ignoreURLParametersMatching RegExps to test against\n * each search parameter name. Matches mean that the search parameter should be\n * ignored.\n * @return {URL} The URL with any ignored search parameters removed.\n *\n * @private\n * @memberof module:workbox-precaching\n */\n\nfunction removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching = []) {\n  // Convert the iterable into an array at the start of the loop to make sure\n  // deletion doesn't mess up iteration.\n  for (const paramName of [...urlObject.searchParams.keys()]) {\n    if (ignoreURLParametersMatching.some(regExp => regExp.test(paramName))) {\n      urlObject.searchParams.delete(paramName);\n    }\n  }\n\n  return urlObject;\n}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/utils/removeIgnoredSearchParams.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/NavigationRoute.js":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-routing/NavigationRoute.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NavigationRoute\": () => (/* binding */ NavigationRoute)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _Route_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.js */ \"./node_modules/workbox-routing/Route.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * NavigationRoute makes it easy to create a\n * [Route]{@link module:workbox-routing.Route} that matches for browser\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n *\n * It will only match incoming Requests whose\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n * is set to `navigate`.\n *\n * You can optionally only apply this route to a subset of navigation requests\n * by using one or both of the `denylist` and `allowlist` parameters.\n *\n * @memberof module:workbox-routing\n * @extends module:workbox-routing.Route\n */\n\nclass NavigationRoute extends _Route_js__WEBPACK_IMPORTED_MODULE_2__.Route {\n  /**\n   * If both `denylist` and `allowlist` are provided, the `denylist` will\n   * take precedence and the request will not match this route.\n   *\n   * The regular expressions in `allowlist` and `denylist`\n   * are matched against the concatenated\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n   * portions of the requested URL.\n   *\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {Object} options\n   * @param {Array<RegExp>} [options.denylist] If any of these patterns match,\n   * the route will not handle the request (even if a allowlist RegExp matches).\n   * @param {Array<RegExp>} [options.allowlist=[/./]] If any of these patterns\n   * match the URL's pathname and search parameter, the route will handle the\n   * request (assuming the denylist doesn't match).\n   */\n  constructor(handler, {\n    allowlist = [/./],\n    denylist = []\n  } = {}) {\n    if (false) {}\n\n    super(options => this._match(options), handler);\n    this._allowlist = allowlist;\n    this._denylist = denylist;\n  }\n  /**\n   * Routes match handler.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {Request} options.request\n   * @return {boolean}\n   *\n   * @private\n   */\n\n\n  _match({\n    url,\n    request\n  }) {\n    if (request && request.mode !== 'navigate') {\n      return false;\n    }\n\n    const pathnameAndSearch = url.pathname + url.search;\n\n    for (const regExp of this._denylist) {\n      if (regExp.test(pathnameAndSearch)) {\n        if (false) {}\n\n        return false;\n      }\n    }\n\n    if (this._allowlist.some(regExp => regExp.test(pathnameAndSearch))) {\n      if (false) {}\n\n      return true;\n    }\n\n    if (false) {}\n\n    return false;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/NavigationRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/RegExpRoute.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-routing/RegExpRoute.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegExpRoute\": () => (/* binding */ RegExpRoute)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _Route_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.js */ \"./node_modules/workbox-routing/Route.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link module:workbox-routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n *\n * @memberof module:workbox-routing\n * @extends module:workbox-routing.Route\n */\n\nclass RegExpRoute extends _Route_js__WEBPACK_IMPORTED_MODULE_2__.Route {\n  /**\n   * If the regular expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * the captured values will be passed to the\n   * [handler's]{@link module:workbox-routing~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (false) {}\n\n    const match = ({\n      url\n    }) => {\n      const result = regExp.exec(url.href); // Return immediately if there's no match.\n\n      if (!result) {\n        return;\n      } // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n\n\n      if (url.origin !== location.origin && result.index !== 0) {\n        if (false) {}\n\n        return;\n      } // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n\n\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/RegExpRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/Route.js":
/*!***********************************************!*\
  !*** ./node_modules/workbox-routing/Route.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Route\": () => (/* binding */ Route)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/workbox-routing/utils/constants.js\");\n/* harmony import */ var _utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/normalizeHandler.js */ \"./node_modules/workbox-routing/utils/normalizeHandler.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_3__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof module:workbox-routing\n */\n\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {module:workbox-routing~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method = _utils_constants_js__WEBPACK_IMPORTED_MODULE_1__.defaultMethod) {\n    if (false) {} // These values are referenced directly by Router so cannot be\n    // altered by minificaton.\n\n\n    this.handler = (0,_utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_2__.normalizeHandler)(handler);\n    this.match = match;\n    this.method = method;\n  }\n  /**\n   *\n   * @param {module:workbox-routing-handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response\n   */\n\n\n  setCatchHandler(handler) {\n    this.catchHandler = (0,_utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_2__.normalizeHandler)(handler);\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/Route.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/Router.js":
/*!************************************************!*\
  !*** ./node_modules/workbox-routing/Router.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Router\": () => (/* binding */ Router)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/constants.js */ \"./node_modules/workbox-routing/utils/constants.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var _utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/normalizeHandler.js */ \"./node_modules/workbox-routing/utils/normalizeHandler.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_6__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link module:workbox-routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof module:workbox-routing\n */\n\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\n   * @return {Map<string, Array<module:workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n\n\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n\n\n  addFetchListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n\n\n  addCacheListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('message', event => {\n      // event.data is type 'any'\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        // eslint-disable-line\n        const {\n          payload\n        } = event.data; // eslint-disable-line\n\n        if (false) {}\n\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request,\n            event\n          }); // TODO(philipwalton): TypeScript errors without this typecast for\n          // some reason (probably a bug). The real type here should work but\n          // doesn't: `Array<Promise<Response> | undefined>`.\n        })); // TypeScript\n\n        event.waitUntil(requestPromises); // If a MessageChannel was used, reply to the message on success.\n\n        if (event.ports && event.ports[0]) {\n          void requestPromises.then(() => event.ports[0].postMessage(true));\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle.\n   * @param {ExtendableEvent} options.event The event that triggered the\n   *     request.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n\n\n  handleRequest({\n    request,\n    event\n  }) {\n    if (false) {}\n\n    const url = new URL(request.url, location.href);\n\n    if (!url.protocol.startsWith('http')) {\n      if (false) {}\n\n      return;\n    }\n\n    const sameOrigin = url.origin === location.origin;\n    const {\n      params,\n      route\n    } = this.findMatchingRoute({\n      event,\n      request,\n      sameOrigin,\n      url\n    });\n    let handler = route && route.handler;\n    const debugMessages = [];\n\n    if (false) {} // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n\n\n    const method = request.method;\n\n    if (!handler && this._defaultHandlerMap.has(method)) {\n      if (false) {}\n\n      handler = this._defaultHandlerMap.get(method);\n    }\n\n    if (!handler) {\n      if (false) {}\n\n      return;\n    }\n\n    if (false) {} // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n\n\n    let responsePromise;\n\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    } // Get route's catch handler, if it exists\n\n\n    const catchHandler = route && route.catchHandler;\n\n    if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n      responsePromise = responsePromise.catch(async err => {\n        // If there's a route catch handler, process that first\n        if (catchHandler) {\n          if (false) {}\n\n          try {\n            return await catchHandler.handle({\n              url,\n              request,\n              event,\n              params\n            });\n          } catch (catchErr) {\n            if (catchErr instanceof Error) {\n              err = catchErr;\n            }\n          }\n        }\n\n        if (this._catchHandler) {\n          if (false) {}\n\n          return this._catchHandler.handle({\n            url,\n            request,\n            event\n          });\n        }\n\n        throw err;\n      });\n    }\n\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n   *     against the current origin.\n   * @param {Request} options.request The request to match.\n   * @param {Event} options.event The corresponding event.\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n\n\n  findMatchingRoute({\n    url,\n    sameOrigin,\n    request,\n    event\n  }) {\n    const routes = this._routes.get(request.method) || [];\n\n    for (const route of routes) {\n      let params; // route.match returns type any, not possible to change right now.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n      const matchResult = route.match({\n        url,\n        sameOrigin,\n        request,\n        event\n      });\n\n      if (matchResult) {\n        if (false) {} // See https://github.com/GoogleChrome/workbox/issues/2079\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n        params = matchResult;\n\n        if (Array.isArray(params) && params.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = undefined;\n        } else if (matchResult.constructor === Object && // eslint-disable-line\n        Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = undefined;\n        } else if (typeof matchResult === 'boolean') {\n          // For the boolean value true (rather than just something truth-y),\n          // don't set params.\n          // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n          params = undefined;\n        } // Return early if have a match.\n\n\n        return {\n          route,\n          params\n        };\n      }\n    } // If no match was found above, return and empty object.\n\n\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to associate with this\n   * default handler. Each method has its own default.\n   */\n\n\n  setDefaultHandler(handler, method = _utils_constants_js__WEBPACK_IMPORTED_MODULE_2__.defaultMethod) {\n    this._defaultHandlerMap.set(method, (0,_utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_4__.normalizeHandler)(handler));\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {module:workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n\n\n  setCatchHandler(handler) {\n    this._catchHandler = (0,_utils_normalizeHandler_js__WEBPACK_IMPORTED_MODULE_4__.normalizeHandler)(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {module:workbox-routing.Route} route The route to register.\n   */\n\n\n  registerRoute(route) {\n    if (false) {}\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    } // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n\n\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {module:workbox-routing.Route} route The route to unregister.\n   */\n\n\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_5__.WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_5__.WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/Router.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/_version.js":
/*!**************************************************!*\
  !*** ./node_modules/workbox-routing/_version.js ***!
  \**************************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:routing:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/index.js":
/*!***********************************************!*\
  !*** ./node_modules/workbox-routing/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NavigationRoute\": () => (/* reexport safe */ _NavigationRoute_js__WEBPACK_IMPORTED_MODULE_0__.NavigationRoute),\n/* harmony export */   \"RegExpRoute\": () => (/* reexport safe */ _RegExpRoute_js__WEBPACK_IMPORTED_MODULE_1__.RegExpRoute),\n/* harmony export */   \"registerRoute\": () => (/* reexport safe */ _registerRoute_js__WEBPACK_IMPORTED_MODULE_2__.registerRoute),\n/* harmony export */   \"Route\": () => (/* reexport safe */ _Route_js__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _Router_js__WEBPACK_IMPORTED_MODULE_4__.Router),\n/* harmony export */   \"setCatchHandler\": () => (/* reexport safe */ _setCatchHandler_js__WEBPACK_IMPORTED_MODULE_5__.setCatchHandler),\n/* harmony export */   \"setDefaultHandler\": () => (/* reexport safe */ _setDefaultHandler_js__WEBPACK_IMPORTED_MODULE_6__.setDefaultHandler)\n/* harmony export */ });\n/* harmony import */ var _NavigationRoute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NavigationRoute.js */ \"./node_modules/workbox-routing/NavigationRoute.js\");\n/* harmony import */ var _RegExpRoute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RegExpRoute.js */ \"./node_modules/workbox-routing/RegExpRoute.js\");\n/* harmony import */ var _registerRoute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./registerRoute.js */ \"./node_modules/workbox-routing/registerRoute.js\");\n/* harmony import */ var _Route_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Route.js */ \"./node_modules/workbox-routing/Route.js\");\n/* harmony import */ var _Router_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Router.js */ \"./node_modules/workbox-routing/Router.js\");\n/* harmony import */ var _setCatchHandler_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./setCatchHandler.js */ \"./node_modules/workbox-routing/setCatchHandler.js\");\n/* harmony import */ var _setDefaultHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./setDefaultHandler.js */ \"./node_modules/workbox-routing/setDefaultHandler.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_7__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n/**\n * @module workbox-routing\n */\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/index.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/registerRoute.js":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-routing/registerRoute.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"registerRoute\": () => (/* binding */ registerRoute)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _Route_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Route.js */ \"./node_modules/workbox-routing/Route.js\");\n/* harmony import */ var _RegExpRoute_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RegExpRoute.js */ \"./node_modules/workbox-routing/RegExpRoute.js\");\n/* harmony import */ var _utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.js */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_5__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * Easily register a RegExp, string, or function with a caching\n * strategy to a singleton Router instance.\n *\n * This method will generate a Route for you if needed and\n * call [registerRoute()]{@link module:workbox-routing.Router#registerRoute}.\n *\n * @param {RegExp|string|module:workbox-routing.Route~matchCallback|module:workbox-routing.Route} capture\n * If the capture param is a `Route`, all other arguments will be ignored.\n * @param {module:workbox-routing~handlerCallback} [handler] A callback\n * function that returns a Promise resulting in a Response. This parameter\n * is required if `capture` is not a `Route` object.\n * @param {string} [method='GET'] The HTTP method to match the Route\n * against.\n * @return {module:workbox-routing.Route} The generated `Route`(Useful for\n * unregistering).\n *\n * @memberof module:workbox-routing\n */\n\nfunction registerRoute(capture, handler, method) {\n  let route;\n\n  if (typeof capture === 'string') {\n    const captureUrl = new URL(capture, location.href);\n\n    if (false) {}\n\n    const matchCallback = ({\n      url\n    }) => {\n      if (false) {}\n\n      return url.href === captureUrl.href;\n    }; // If `capture` is a string then `handler` and `method` must be present.\n\n\n    route = new _Route_js__WEBPACK_IMPORTED_MODULE_2__.Route(matchCallback, handler, method);\n  } else if (capture instanceof RegExp) {\n    // If `capture` is a `RegExp` then `handler` and `method` must be present.\n    route = new _RegExpRoute_js__WEBPACK_IMPORTED_MODULE_3__.RegExpRoute(capture, handler, method);\n  } else if (typeof capture === 'function') {\n    // If `capture` is a function then `handler` and `method` must be present.\n    route = new _Route_js__WEBPACK_IMPORTED_MODULE_2__.Route(capture, handler, method);\n  } else if (capture instanceof _Route_js__WEBPACK_IMPORTED_MODULE_2__.Route) {\n    route = capture;\n  } else {\n    throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__.WorkboxError('unsupported-route-type', {\n      moduleName: 'workbox-routing',\n      funcName: 'registerRoute',\n      paramName: 'capture'\n    });\n  }\n\n  const defaultRouter = (0,_utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_4__.getOrCreateDefaultRouter)();\n  defaultRouter.registerRoute(route);\n  return route;\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/registerRoute.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/setCatchHandler.js":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-routing/setCatchHandler.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setCatchHandler\": () => (/* binding */ setCatchHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.js */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * If a Route throws an error while handling a request, this `handler`\n * will be called and given a chance to provide a response.\n *\n * @param {module:workbox-routing~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @memberof module:workbox-routing\n */\n\nfunction setCatchHandler(handler) {\n  const defaultRouter = (0,_utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreateDefaultRouter)();\n  defaultRouter.setCatchHandler(handler);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/setCatchHandler.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/setDefaultHandler.js":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-routing/setDefaultHandler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setDefaultHandler\": () => (/* binding */ setDefaultHandler)\n/* harmony export */ });\n/* harmony import */ var _utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/getOrCreateDefaultRouter.js */ \"./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * Define a default `handler` that's called when no routes explicitly\n * match the incoming request.\n *\n * Without a default handler, unmatched requests will go against the\n * network as if there were no service worker present.\n *\n * @param {module:workbox-routing~handlerCallback} handler A callback\n * function that returns a Promise resulting in a Response.\n *\n * @memberof module:workbox-routing\n */\n\nfunction setDefaultHandler(handler) {\n  const defaultRouter = (0,_utils_getOrCreateDefaultRouter_js__WEBPACK_IMPORTED_MODULE_0__.getOrCreateDefaultRouter)();\n  defaultRouter.setDefaultHandler(handler);\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/setDefaultHandler.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/constants.js":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-routing/utils/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultMethod\": () => (/* binding */ defaultMethod),\n/* harmony export */   \"validMethods\": () => (/* binding */ validMethods)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\n\nconst defaultMethod = 'GET';\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\n\nconst validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/utils/constants.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js":
/*!************************************************************************!*\
  !*** ./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getOrCreateDefaultRouter\": () => (/* binding */ getOrCreateDefaultRouter)\n/* harmony export */ });\n/* harmony import */ var _Router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Router.js */ \"./node_modules/workbox-routing/Router.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\nlet defaultRouter;\n/**\n * Creates a new, singleton Router instance if one does not exist. If one\n * does already exist, that instance is returned.\n *\n * @private\n * @return {Router}\n */\n\nconst getOrCreateDefaultRouter = () => {\n  if (!defaultRouter) {\n    defaultRouter = new _Router_js__WEBPACK_IMPORTED_MODULE_0__.Router(); // The helpers that use the default Router assume these listeners exist.\n\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n  }\n\n  return defaultRouter;\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/utils/getOrCreateDefaultRouter.js?");

/***/ }),

/***/ "./node_modules/workbox-routing/utils/normalizeHandler.js":
/*!****************************************************************!*\
  !*** ./node_modules/workbox-routing/utils/normalizeHandler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"normalizeHandler\": () => (/* binding */ normalizeHandler)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-routing/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_1__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n/**\n * @param {function()|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\n\nconst normalizeHandler = handler => {\n  if (handler && typeof handler === 'object') {\n    if (false) {}\n\n    return handler;\n  } else {\n    if (false) {}\n\n    return {\n      handle: handler\n    };\n  }\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/utils/normalizeHandler.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/CacheFirst.js":
/*!*******************************************************!*\
  !*** ./node_modules/workbox-strategies/CacheFirst.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheFirst\": () => (/* binding */ CacheFirst)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/messages.js */ \"./node_modules/workbox-strategies/utils/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_5__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n * request strategy.\n *\n * A cache first strategy is useful for assets that have been revisioned,\n * such as URLs like `/styles/example.a8f5f1.css`, since they\n * can be cached for long periods of time.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\n\nclass CacheFirst extends _Strategy_js__WEBPACK_IMPORTED_MODULE_3__.Strategy {\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const logs = [];\n\n    if (false) {}\n\n    let response = await handler.cacheMatch(request);\n    let error = undefined;\n\n    if (!response) {\n      if (false) {}\n\n      try {\n        response = await handler.fetchAndCachePut(request);\n      } catch (err) {\n        if (err instanceof Error) {\n          error = err;\n        }\n      }\n\n      if (false) {}\n    } else {\n      if (false) {}\n    }\n\n    if (false) {}\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__.WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n\n    return response;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/CacheFirst.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/CacheOnly.js":
/*!******************************************************!*\
  !*** ./node_modules/workbox-strategies/CacheOnly.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheOnly\": () => (/* binding */ CacheOnly)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/messages.js */ \"./node_modules/workbox-strategies/utils/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_5__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * An implementation of a\n * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If there is no cache match, this will throw a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\n\nclass CacheOnly extends _Strategy_js__WEBPACK_IMPORTED_MODULE_3__.Strategy {\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    if (false) {}\n\n    const response = await handler.cacheMatch(request);\n\n    if (false) {}\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__.WorkboxError('no-response', {\n        url: request.url\n      });\n    }\n\n    return response;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/CacheOnly.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/NetworkFirst.js":
/*!*********************************************************!*\
  !*** ./node_modules/workbox-strategies/NetworkFirst.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NetworkFirst\": () => (/* binding */ NetworkFirst)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _plugins_cacheOkAndOpaquePlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/cacheOkAndOpaquePlugin.js */ \"./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/messages.js */ \"./node_modules/workbox-strategies/utils/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_6__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n * request strategy.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\n\nclass NetworkFirst extends _Strategy_js__WEBPACK_IMPORTED_MODULE_4__.Strategy {\n  /**\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n   * that fail to respond within the timeout will fallback to the cache.\n   *\n   * This option can be used to combat\n   * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n   * scenarios.\n   */\n  constructor(options = {}) {\n    super(options); // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n    // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n\n    if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {\n      this.plugins.unshift(_plugins_cacheOkAndOpaquePlugin_js__WEBPACK_IMPORTED_MODULE_3__.cacheOkAndOpaquePlugin);\n    }\n\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n\n    if (false) {}\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  async _handle(request, handler) {\n    const logs = [];\n\n    if (false) {}\n\n    const promises = [];\n    let timeoutId;\n\n    if (this._networkTimeoutSeconds) {\n      const {\n        id,\n        promise\n      } = this._getTimeoutPromise({\n        request,\n        logs,\n        handler\n      });\n\n      timeoutId = id;\n      promises.push(promise);\n    }\n\n    const networkPromise = this._getNetworkPromise({\n      timeoutId,\n      request,\n      logs,\n      handler\n    });\n\n    promises.push(networkPromise);\n    const response = await handler.waitUntil((async () => {\n      // Promise.race() will resolve as soon as the first promise resolves.\n      return (await handler.waitUntil(Promise.race(promises))) || ( // If Promise.race() resolved with null, it might be due to a network\n      // timeout + a cache miss. If that were to happen, we'd rather wait until\n      // the networkPromise resolves instead of returning null.\n      // Note that it's fine to await an already-resolved promise, so we don't\n      // have to check to see if it's still \"in flight\".\n      await networkPromise);\n    })());\n\n    if (false) {}\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__.WorkboxError('no-response', {\n        url: request.url\n      });\n    }\n\n    return response;\n  }\n  /**\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs array\n   * @param {Event} options.event\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n\n\n  _getTimeoutPromise({\n    request,\n    logs,\n    handler\n  }) {\n    let timeoutId;\n    const timeoutPromise = new Promise(resolve => {\n      const onNetworkTimeout = async () => {\n        if (false) {}\n\n        resolve(await handler.cacheMatch(request));\n      };\n\n      timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n    });\n    return {\n      promise: timeoutPromise,\n      id: timeoutId\n    };\n  }\n  /**\n   * @param {Object} options\n   * @param {number|undefined} options.timeoutId\n   * @param {Request} options.request\n   * @param {Array} options.logs A reference to the logs Array.\n   * @param {Event} options.event\n   * @return {Promise<Response>}\n   *\n   * @private\n   */\n\n\n  async _getNetworkPromise({\n    timeoutId,\n    request,\n    logs,\n    handler\n  }) {\n    let error;\n    let response;\n\n    try {\n      response = await handler.fetchAndCachePut(request);\n    } catch (fetchError) {\n      if (fetchError instanceof Error) {\n        error = fetchError;\n      }\n    }\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    if (false) {}\n\n    if (error || !response) {\n      response = await handler.cacheMatch(request);\n\n      if (false) {}\n    }\n\n    return response;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/NetworkFirst.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/NetworkOnly.js":
/*!********************************************************!*\
  !*** ./node_modules/workbox-strategies/NetworkOnly.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NetworkOnly\": () => (/* binding */ NetworkOnly)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_timeout_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/timeout.js */ \"./node_modules/workbox-core/_private/timeout.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/messages.js */ \"./node_modules/workbox-strategies/utils/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_6__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n * request strategy.\n *\n * This class is useful if you want to take advantage of any\n * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n *\n * If the network request fails, this will throw a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\n\nclass NetworkOnly extends _Strategy_js__WEBPACK_IMPORTED_MODULE_4__.Strategy {\n  /**\n   * @param {Object} [options]\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {number} [options.networkTimeoutSeconds] If set, any network requests\n   * that fail to respond within the timeout will result in a network error.\n   */\n  constructor(options = {}) {\n    super(options);\n    this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  async _handle(request, handler) {\n    if (false) {}\n\n    let error = undefined;\n    let response;\n\n    try {\n      const promises = [handler.fetch(request)];\n\n      if (this._networkTimeoutSeconds) {\n        const timeoutPromise = (0,workbox_core_private_timeout_js__WEBPACK_IMPORTED_MODULE_2__.timeout)(this._networkTimeoutSeconds * 1000);\n        promises.push(timeoutPromise);\n      }\n\n      response = await Promise.race(promises);\n\n      if (!response) {\n        throw new Error(`Timed out the network response after ` + `${this._networkTimeoutSeconds} seconds.`);\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        error = err;\n      }\n    }\n\n    if (false) {}\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_3__.WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n\n    return response;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/NetworkOnly.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/StaleWhileRevalidate.js":
/*!*****************************************************************!*\
  !*** ./node_modules/workbox-strategies/StaleWhileRevalidate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StaleWhileRevalidate\": () => (/* binding */ StaleWhileRevalidate)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _plugins_cacheOkAndOpaquePlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plugins/cacheOkAndOpaquePlugin.js */ \"./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/messages.js */ \"./node_modules/workbox-strategies/utils/messages.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_6__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n/**\n * An implementation of a\n * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n * request strategy.\n *\n * Resources are requested from both the cache and the network in parallel.\n * The strategy will respond with the cached version if available, otherwise\n * wait for the network response. The cache is updated with the network response\n * with each successful request.\n *\n * By default, this strategy will cache responses with a 200 status code as\n * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n * Opaque responses are cross-origin requests where the response doesn't\n * support [CORS]{@link https://enable-cors.org/}.\n *\n * If the network request fails, and there is no cache match, this will throw\n * a `WorkboxError` exception.\n *\n * @extends module:workbox-strategies.Strategy\n * @memberof module:workbox-strategies\n */\n\nclass StaleWhileRevalidate extends _Strategy_js__WEBPACK_IMPORTED_MODULE_4__.Strategy {\n  /**\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n   */\n  constructor(options = {}) {\n    super(options); // If this instance contains no plugins with a 'cacheWillUpdate' callback,\n    // prepend the `cacheOkAndOpaquePlugin` plugin to the plugins list.\n\n    if (!this.plugins.some(p => 'cacheWillUpdate' in p)) {\n      this.plugins.unshift(_plugins_cacheOkAndOpaquePlugin_js__WEBPACK_IMPORTED_MODULE_3__.cacheOkAndOpaquePlugin);\n    }\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {module:workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n\n\n  async _handle(request, handler) {\n    const logs = [];\n\n    if (false) {}\n\n    const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(() => {// Swallow this error because a 'no-response' error will be thrown in\n      // main handler return flow. This will be in the `waitUntil()` flow.\n    });\n    let response = await handler.cacheMatch(request);\n    let error;\n\n    if (response) {\n      if (false) {}\n    } else {\n      if (false) {}\n\n      try {\n        // NOTE(philipwalton): Really annoying that we have to type cast here.\n        // https://github.com/microsoft/TypeScript/issues/20006\n        response = await fetchAndCachePromise;\n      } catch (err) {\n        if (err instanceof Error) {\n          error = err;\n        }\n      }\n    }\n\n    if (false) {}\n\n    if (!response) {\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_2__.WorkboxError('no-response', {\n        url: request.url,\n        error\n      });\n    }\n\n    return response;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/StaleWhileRevalidate.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/Strategy.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-strategies/Strategy.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Strategy\": () => (/* binding */ Strategy)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/cacheNames.js */ \"./node_modules/workbox-core/_private/cacheNames.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var _StrategyHandler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StrategyHandler.js */ \"./node_modules/workbox-strategies/StrategyHandler.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_5__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof module:workbox-strategies\n */\n\nclass Strategy {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * [workbox-core]{@link module:workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  constructor(options = {}) {\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * [workbox-core]{@link module:workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = workbox_core_private_cacheNames_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * [route]{@link module:workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n\n\n  handle(options) {\n    const [responseDone] = this.handleAll(options);\n    return responseDone;\n  }\n  /**\n   * Similar to [`handle()`]{@link module:workbox-strategies.Strategy~handle}, but\n   * instead of just returning a `Promise` that resolves to a `Response` it\n   * it will return an tuple of [response, done] promises, where the former\n   * (`response`) is equivalent to what `handle()` returns, and the latter is a\n   * Promise that will resolve once any promises that were added to\n   * `event.waitUntil()` as part of performing the strategy have completed.\n   *\n   * You can await the `done` promise to ensure any extra work performed by\n   * the strategy (usually caching responses) completes successfully.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   * @return {Array<Promise>} A tuple of [response, done]\n   *     promises that can be used to determine when the response resolves as\n   *     well as when the handler has completed all its work.\n   */\n\n\n  handleAll(options) {\n    // Allow for flexible options to be passed.\n    if (options instanceof FetchEvent) {\n      options = {\n        event: options,\n        request: options.request\n      };\n    }\n\n    const event = options.event;\n    const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n    const params = 'params' in options ? options.params : undefined;\n    const handler = new _StrategyHandler_js__WEBPACK_IMPORTED_MODULE_4__.StrategyHandler(this, {\n      event,\n      request,\n      params\n    });\n\n    const responseDone = this._getResponse(handler, request, event);\n\n    const handlerDone = this._awaitComplete(responseDone, handler, request, event); // Return an array of promises, suitable for use with Promise.all().\n\n\n    return [responseDone, handlerDone];\n  }\n\n  async _getResponse(handler, request, event) {\n    await handler.runCallbacks('handlerWillStart', {\n      event,\n      request\n    });\n    let response = undefined;\n\n    try {\n      response = await this._handle(request, handler); // The \"official\" Strategy subclasses all throw this error automatically,\n      // but in case a third-party Strategy doesn't, ensure that we have a\n      // consistent failure when there's no response or an error response.\n\n      if (!response || response.type === 'error') {\n        throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_1__.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        for (const callback of handler.iterateCallbacks('handlerDidError')) {\n          response = await callback({\n            error,\n            event,\n            request\n          });\n\n          if (response) {\n            break;\n          }\n        }\n      }\n\n      if (!response) {\n        throw error;\n      } else if (false) {}\n    }\n\n    for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n      response = await callback({\n        event,\n        request,\n        response\n      });\n    }\n\n    return response;\n  }\n\n  async _awaitComplete(responseDone, handler, request, event) {\n    let response;\n    let error;\n\n    try {\n      response = await responseDone;\n    } catch (error) {// Ignore errors, as response errors should be caught via the `response`\n      // promise above. The `done` promise will only throw for errors in\n      // promises passed to `handler.waitUntil()`.\n    }\n\n    try {\n      await handler.runCallbacks('handlerDidRespond', {\n        event,\n        request,\n        response\n      });\n      await handler.doneWaiting();\n    } catch (waitUntilError) {\n      if (waitUntilError instanceof Error) {\n        error = waitUntilError;\n      }\n    }\n\n    await handler.runCallbacks('handlerDidComplete', {\n      event,\n      request,\n      response,\n      error: error\n    });\n    handler.destroy();\n\n    if (error) {\n      throw error;\n    }\n  }\n\n}\n\n\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the [`handler`]{@link module:workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {module:workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof module:workbox-strategies.Strategy\n */\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/Strategy.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/StrategyHandler.js":
/*!************************************************************!*\
  !*** ./node_modules/workbox-strategies/StrategyHandler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StrategyHandler\": () => (/* binding */ StrategyHandler)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/assert.js */ \"./node_modules/workbox-core/_private/assert.js\");\n/* harmony import */ var workbox_core_private_cacheMatchIgnoreParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/cacheMatchIgnoreParams.js */ \"./node_modules/workbox-core/_private/cacheMatchIgnoreParams.js\");\n/* harmony import */ var workbox_core_private_Deferred_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-core/_private/Deferred.js */ \"./node_modules/workbox-core/_private/Deferred.js\");\n/* harmony import */ var workbox_core_private_executeQuotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-core/_private/executeQuotaErrorCallbacks.js */ \"./node_modules/workbox-core/_private/executeQuotaErrorCallbacks.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_timeout_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! workbox-core/_private/timeout.js */ \"./node_modules/workbox-core/_private/timeout.js\");\n/* harmony import */ var workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! workbox-core/_private/WorkboxError.js */ \"./node_modules/workbox-core/_private/WorkboxError.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_8__);\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n\n\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * [handle()]{@link module:workbox-strategies.Strategy~handle} or\n * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof module:workbox-strategies\n */\n\n\nclass StrategyHandler {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {module:workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   *     [match callback]{@link module:workbox-routing~matchCallback},\n   *     (if applicable).\n   */\n  constructor(strategy, options) {\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * [match callback]{@link module:workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    if (false) {}\n\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new workbox_core_private_Deferred_js__WEBPACK_IMPORTED_MODULE_2__.Deferred();\n    this._extendLifetimePromises = []; // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n\n    this._plugins = [...strategy.plugins];\n    this._pluginStateMap = new Map();\n\n    for (const plugin of this._plugins) {\n      this._pluginStateMap.set(plugin, {});\n    }\n\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` (for non-navigation requests) and\n   * `plugins` defined on the `Strategy` object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n\n\n  async fetch(input) {\n    const {\n      event\n    } = this;\n    let request = toRequest(input);\n\n    if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n      const possiblePreloadResponse = await event.preloadResponse;\n\n      if (possiblePreloadResponse) {\n        if (false) {}\n\n        return possiblePreloadResponse;\n      }\n    } // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n\n\n    const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n\n    try {\n      for (const cb of this.iterateCallbacks('requestWillFetch')) {\n        request = await cb({\n          request: request.clone(),\n          event\n        });\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_7__.WorkboxError('plugin-error-request-will-fetch', {\n          thrownErrorMessage: err.message\n        });\n      }\n    } // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (most likely from a `fetch` event) different\n    // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n\n\n    const pluginFilteredRequest = request.clone();\n\n    try {\n      let fetchResponse; // See https://github.com/GoogleChrome/workbox/issues/1796\n\n      fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n\n      if (false) {}\n\n      for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n        fetchResponse = await callback({\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n      }\n\n      return fetchResponse;\n    } catch (error) {\n      if (false) {} // `originalRequest` will only exist if a `fetchDidFail` callback\n      // is being used (see above).\n\n\n      if (originalRequest) {\n        await this.runCallbacks('fetchDidFail', {\n          error: error,\n          event,\n          originalRequest: originalRequest.clone(),\n          request: pluginFilteredRequest.clone()\n        });\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n   * the response generated by `this.fetch()`.\n   *\n   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n   * so you do not have to manually call `waitUntil()` on the event.\n   *\n   * @param {Request|string} input The request or URL to fetch and cache.\n   * @return {Promise<Response>}\n   */\n\n\n  async fetchAndCachePut(input) {\n    const response = await this.fetch(input);\n    const responseClone = response.clone();\n    void this.waitUntil(this.cachePut(input, responseClone));\n    return response;\n  }\n  /**\n   * Matches a request from the cache (and invokes any applicable plugin\n   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n   * defined on the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cachedResponseWillByUsed()\n   *\n   * @param {Request|string} key The Request or URL to use as the cache key.\n   * @return {Promise<Response|undefined>} A matching response, if found.\n   */\n\n\n  async cacheMatch(key) {\n    const request = toRequest(key);\n    let cachedResponse;\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const effectiveRequest = await this.getCacheKey(request, 'read');\n    const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n      cacheName\n    });\n    cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n\n    if (false) {}\n\n    for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n      cachedResponse = (await callback({\n        cacheName,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest,\n        event: this.event\n      })) || undefined;\n    }\n\n    return cachedResponse;\n  }\n  /**\n   * Puts a request/response pair in the cache (and invokes any applicable\n   * plugin callback methods) using the `cacheName` and `plugins` defined on\n   * the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cacheWillUpdate()\n   * - cacheDidUpdate()\n   *\n   * @param {Request|string} key The request or URL to use as the cache key.\n   * @param {Response} response The response to cache.\n   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n   * not be cached, and `true` otherwise.\n   */\n\n\n  async cachePut(key, response) {\n    const request = toRequest(key); // Run in the next task to avoid blocking other cache reads.\n    // https://github.com/w3c/ServiceWorker/issues/1397\n\n    await (0,workbox_core_private_timeout_js__WEBPACK_IMPORTED_MODULE_6__.timeout)(0);\n    const effectiveRequest = await this.getCacheKey(request, 'write');\n\n    if (false) {}\n\n    if (!response) {\n      if (false) {}\n\n      throw new workbox_core_private_WorkboxError_js__WEBPACK_IMPORTED_MODULE_7__.WorkboxError('cache-put-with-no-response', {\n        url: (0,workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_4__.getFriendlyURL)(effectiveRequest.url)\n      });\n    }\n\n    const responseToCache = await this._ensureResponseSafeToCache(response);\n\n    if (!responseToCache) {\n      if (false) {}\n\n      return false;\n    }\n\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const cache = await self.caches.open(cacheName);\n    const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n    const oldResponse = hasCacheUpdateCallback ? await (0,workbox_core_private_cacheMatchIgnoreParams_js__WEBPACK_IMPORTED_MODULE_1__.cacheMatchIgnoreParams)( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n    // feature. Consider into ways to only add this behavior if using\n    // precaching.\n    cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n\n    if (false) {}\n\n    try {\n      await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n    } catch (error) {\n      if (error instanceof Error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n          await (0,workbox_core_private_executeQuotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_3__.executeQuotaErrorCallbacks)();\n        }\n\n        throw error;\n      }\n    }\n\n    for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n      await callback({\n        cacheName,\n        oldResponse,\n        newResponse: responseToCache.clone(),\n        request: effectiveRequest,\n        event: this.event\n      });\n    }\n\n    return true;\n  }\n  /**\n   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n   * executes any of those callbacks found in sequence. The final `Request`\n   * object returned by the last plugin is treated as the cache key for cache\n   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n   * been registered, the passed request is returned unmodified\n   *\n   * @param {Request} request\n   * @param {string} mode\n   * @return {Promise<Request>}\n   */\n\n\n  async getCacheKey(request, mode) {\n    if (!this._cacheKeys[mode]) {\n      let effectiveRequest = request;\n\n      for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n        effectiveRequest = toRequest(await callback({\n          mode,\n          request: effectiveRequest,\n          event: this.event,\n          // params has a type any can't change right now.\n          params: this.params\n        }));\n      }\n\n      this._cacheKeys[mode] = effectiveRequest;\n    }\n\n    return this._cacheKeys[mode];\n  }\n  /**\n   * Returns true if the strategy has at least one plugin with the given\n   * callback.\n   *\n   * @param {string} name The name of the callback to check for.\n   * @return {boolean}\n   */\n\n\n  hasCallback(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (name in plugin) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Runs all plugin callbacks matching the given name, in order, passing the\n   * given param object (merged ith the current plugin state) as the only\n   * argument.\n   *\n   * Note: since this method runs all plugins, it's not suitable for cases\n   * where the return value of a callback needs to be applied prior to calling\n   * the next callback. See\n   * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}\n   * below for how to handle that case.\n   *\n   * @param {string} name The name of the callback to run within each plugin.\n   * @param {Object} param The object to pass as the first (and only) param\n   *     when executing each callback. This object will be merged with the\n   *     current plugin state prior to callback execution.\n   */\n\n\n  async runCallbacks(name, param) {\n    for (const callback of this.iterateCallbacks(name)) {\n      // TODO(philipwalton): not sure why `any` is needed. It seems like\n      // this should work with `as WorkboxPluginCallbackParam[C]`.\n      await callback(param);\n    }\n  }\n  /**\n   * Accepts a callback and returns an iterable of matching plugin callbacks,\n   * where each callback is wrapped with the current handler state (i.e. when\n   * you call each callback, whatever object parameter you pass it will\n   * be merged with the plugin's current state).\n   *\n   * @param {string} name The name fo the callback to run\n   * @return {Array<Function>}\n   */\n\n\n  *iterateCallbacks(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (typeof plugin[name] === 'function') {\n        const state = this._pluginStateMap.get(plugin);\n\n        const statefulCallback = param => {\n          const statefulParam = Object.assign(Object.assign({}, param), {\n            state\n          }); // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n\n          return plugin[name](statefulParam);\n        };\n\n        yield statefulCallback;\n      }\n    }\n  }\n  /**\n   * Adds a promise to the\n   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n   * of the event event associated with the request being handled (usually a\n   * `FetchEvent`).\n   *\n   * Note: you can await\n   * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}\n   * to know when all added promises have settled.\n   *\n   * @param {Promise} promise A promise to add to the extend lifetime promises\n   *     of the event that triggered the request.\n   */\n\n\n  waitUntil(promise) {\n    this._extendLifetimePromises.push(promise);\n\n    return promise;\n  }\n  /**\n   * Returns a promise that resolves once all promises passed to\n   * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}\n   * have settled.\n   *\n   * Note: any work done after `doneWaiting()` settles should be manually\n   * passed to an event's `waitUntil()` method (not this handler's\n   * `waitUntil()` method), otherwise the service worker thread my be killed\n   * prior to your work completing.\n   */\n\n\n  async doneWaiting() {\n    let promise;\n\n    while (promise = this._extendLifetimePromises.shift()) {\n      await promise;\n    }\n  }\n  /**\n   * Stops running the strategy and immediately resolves any pending\n   * `waitUntil()` promises.\n   */\n\n\n  destroy() {\n    this._handlerDeferred.resolve(null);\n  }\n  /**\n   * This method will call cacheWillUpdate on the available plugins (or use\n   * status === 200) to determine if the Response is safe and valid to cache.\n   *\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @return {Promise<Response|undefined>}\n   *\n   * @private\n   */\n\n\n  async _ensureResponseSafeToCache(response) {\n    let responseToCache = response;\n    let pluginsUsed = false;\n\n    for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n      responseToCache = (await callback({\n        request: this.request,\n        response: responseToCache,\n        event: this.event\n      })) || undefined;\n      pluginsUsed = true;\n\n      if (!responseToCache) {\n        break;\n      }\n    }\n\n    if (!pluginsUsed) {\n      if (responseToCache && responseToCache.status !== 200) {\n        responseToCache = undefined;\n      }\n\n      if (false) {}\n    }\n\n    return responseToCache;\n  }\n\n}\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/StrategyHandler.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/_version.js":
/*!*****************************************************!*\
  !*** ./node_modules/workbox-strategies/_version.js ***!
  \*****************************************************/
/***/ (() => {

eval(" // @ts-ignore\n\ntry {\n  self['workbox:strategies:6.2.4'] && _();\n} catch (e) {}\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/_version.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/index.js":
/*!**************************************************!*\
  !*** ./node_modules/workbox-strategies/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheFirst\": () => (/* reexport safe */ _CacheFirst_js__WEBPACK_IMPORTED_MODULE_0__.CacheFirst),\n/* harmony export */   \"CacheOnly\": () => (/* reexport safe */ _CacheOnly_js__WEBPACK_IMPORTED_MODULE_1__.CacheOnly),\n/* harmony export */   \"NetworkFirst\": () => (/* reexport safe */ _NetworkFirst_js__WEBPACK_IMPORTED_MODULE_2__.NetworkFirst),\n/* harmony export */   \"NetworkOnly\": () => (/* reexport safe */ _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_3__.NetworkOnly),\n/* harmony export */   \"StaleWhileRevalidate\": () => (/* reexport safe */ _StaleWhileRevalidate_js__WEBPACK_IMPORTED_MODULE_4__.StaleWhileRevalidate),\n/* harmony export */   \"Strategy\": () => (/* reexport safe */ _Strategy_js__WEBPACK_IMPORTED_MODULE_5__.Strategy),\n/* harmony export */   \"StrategyHandler\": () => (/* reexport safe */ _StrategyHandler_js__WEBPACK_IMPORTED_MODULE_6__.StrategyHandler)\n/* harmony export */ });\n/* harmony import */ var _CacheFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CacheFirst.js */ \"./node_modules/workbox-strategies/CacheFirst.js\");\n/* harmony import */ var _CacheOnly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CacheOnly.js */ \"./node_modules/workbox-strategies/CacheOnly.js\");\n/* harmony import */ var _NetworkFirst_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetworkFirst.js */ \"./node_modules/workbox-strategies/NetworkFirst.js\");\n/* harmony import */ var _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NetworkOnly.js */ \"./node_modules/workbox-strategies/NetworkOnly.js\");\n/* harmony import */ var _StaleWhileRevalidate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StaleWhileRevalidate.js */ \"./node_modules/workbox-strategies/StaleWhileRevalidate.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/workbox-strategies/Strategy.js\");\n/* harmony import */ var _StrategyHandler_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StrategyHandler.js */ \"./node_modules/workbox-strategies/StrategyHandler.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_7__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\n\n\n\n\n\n/**\n * There are common caching strategies that most service workers will need\n * and use. This module provides simple implementations of these strategies.\n *\n * @module workbox-strategies\n */\n\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/index.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"cacheOkAndOpaquePlugin\": () => (/* binding */ cacheOkAndOpaquePlugin)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_0__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\nconst cacheOkAndOpaquePlugin = {\n  /**\n   * Returns a valid response (to allow caching) if the status is 200 (OK) or\n   * 0 (opaque).\n   *\n   * @param {Object} options\n   * @param {Response} options.response\n   * @return {Response|null}\n   *\n   * @private\n   */\n  cacheWillUpdate: async ({\n    response\n  }) => {\n    if (response.status === 200 || response.status === 0) {\n      return response;\n    }\n\n    return null;\n  }\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/plugins/cacheOkAndOpaquePlugin.js?");

/***/ }),

/***/ "./node_modules/workbox-strategies/utils/messages.js":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-strategies/utils/messages.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"messages\": () => (/* binding */ messages)\n/* harmony export */ });\n/* harmony import */ var workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core/_private/logger.js */ \"./node_modules/workbox-core/_private/logger.js\");\n/* harmony import */ var workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-core/_private/getFriendlyURL.js */ \"./node_modules/workbox-core/_private/getFriendlyURL.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_version.js */ \"./node_modules/workbox-strategies/_version.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_version_js__WEBPACK_IMPORTED_MODULE_2__);\n/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n\n\n\nconst messages = {\n  strategyStart: (strategyName, request) => `Using ${strategyName} to respond to '${(0,workbox_core_private_getFriendlyURL_js__WEBPACK_IMPORTED_MODULE_1__.getFriendlyURL)(request.url)}'`,\n  printFinalResponse: response => {\n    if (response) {\n      workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`View the final response here.`);\n      workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.log(response || '[No response returned]');\n      workbox_core_private_logger_js__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n    }\n  }\n};\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/utils/messages.js?");

/***/ }),

/***/ "./src/src-sw.js":
/*!***********************!*\
  !*** ./src/src-sw.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var workbox_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-core */ \"./node_modules/workbox-core/index.mjs\");\n/* harmony import */ var workbox_precaching__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! workbox-precaching */ \"./node_modules/workbox-precaching/index.mjs\");\n/* harmony import */ var workbox_routing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! workbox-routing */ \"./node_modules/workbox-routing/index.mjs\");\n/* harmony import */ var workbox_strategies__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! workbox-strategies */ \"./node_modules/workbox-strategies/index.mjs\");\n/* harmony import */ var workbox_cacheable_response__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! workbox-cacheable-response */ \"./node_modules/workbox-cacheable-response/index.mjs\");\n/* harmony import */ var workbox_expiration__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! workbox-expiration */ \"./node_modules/workbox-expiration/index.mjs\");\n\n\n\n\n\n\n(0,workbox_core__WEBPACK_IMPORTED_MODULE_0__.clientsClaim)();\nself.skipWaiting();\nvar version = \"Verr 9\";\n(0,workbox_precaching__WEBPACK_IMPORTED_MODULE_1__.precacheAndRoute)([{'revision':null,'url':'/22fa3fa56c47da9a1e0c51411047e466.png'},{'revision':null,'url':'/5b21611276d7b186d1ff609bea5ce8f1.png'},{'revision':'69f84dc9c4bac5b8298fb6ef3f7da4cd','url':'/favicon.ico'},{'revision':'7e1ef3f1cf3f5afbdc77e50689553108','url':'/index.html'},{'revision':'60543c166948bea0272609554f5fb8db','url':'/logo192.png'},{'revision':'593389609b0d1374f43b3a4d3421217d','url':'/logo512.png'},{'revision':'b33676f02554fa1b592c4134e616f3ec','url':'/main.js'},{'revision':'acaf4a4af1ad8b3ee27d622d4733bfb4','url':'/manifest.json'}]); // Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.\n\n(0,workbox_routing__WEBPACK_IMPORTED_MODULE_2__.registerRoute)(function (_ref) {\n  var url = _ref.url;\n  return url.origin === 'https://fonts.googleapis.com';\n}, new workbox_strategies__WEBPACK_IMPORTED_MODULE_3__.StaleWhileRevalidate({\n  cacheName: 'google-fonts-stylesheets'\n})); // Cache the underlying font files with a cache-first strategy for 1 year.\n\n(0,workbox_routing__WEBPACK_IMPORTED_MODULE_2__.registerRoute)(function (_ref2) {\n  var url = _ref2.url;\n  return url.origin === 'https://fonts.gstatic.com';\n}, new workbox_strategies__WEBPACK_IMPORTED_MODULE_3__.CacheFirst({\n  cacheName: 'google-fonts-webfonts',\n  plugins: [new workbox_cacheable_response__WEBPACK_IMPORTED_MODULE_4__.CacheableResponsePlugin({\n    statuses: [0, 200]\n  }), new workbox_expiration__WEBPACK_IMPORTED_MODULE_5__.ExpirationPlugin({\n    maxAgeSeconds: 60 * 60 * 24 * 365,\n    maxEntries: 30\n  })]\n}));\n(0,workbox_routing__WEBPACK_IMPORTED_MODULE_2__.registerRoute)(function (_ref3) {\n  var url = _ref3.url;\n  return url.origin === 'https://api.themoviedb.org' || url.pathname === '/3/discover/tv';\n}, new workbox_strategies__WEBPACK_IMPORTED_MODULE_3__.StaleWhileRevalidate({\n  cacheName: 'api-response',\n  plugins: [new workbox_cacheable_response__WEBPACK_IMPORTED_MODULE_4__.CacheableResponsePlugin({\n    statuses: [0, 200]\n  }), new workbox_expiration__WEBPACK_IMPORTED_MODULE_5__.ExpirationPlugin({\n    maxEntries: 1\n  })]\n}));\n(0,workbox_routing__WEBPACK_IMPORTED_MODULE_2__.registerRoute)(function (_ref4) {\n  var request = _ref4.request;\n  return request.destination === 'image';\n}, new workbox_strategies__WEBPACK_IMPORTED_MODULE_3__.CacheFirst({\n  cacheName: 'images',\n  plugins: [new workbox_cacheable_response__WEBPACK_IMPORTED_MODULE_4__.CacheableResponsePlugin({\n    statuses: [0, 200]\n  }), new workbox_expiration__WEBPACK_IMPORTED_MODULE_5__.ExpirationPlugin({\n    maxEntries: 60,\n    maxAgeSeconds: 30 * 24 * 60 * 60 // 30 Days\n\n  })]\n}));\n(0,workbox_routing__WEBPACK_IMPORTED_MODULE_2__.registerRoute)(function (_ref5) {\n  var request = _ref5.request;\n  return request.destination === 'script' || request.destination === 'style';\n}, new workbox_strategies__WEBPACK_IMPORTED_MODULE_3__.StaleWhileRevalidate({\n  cacheName: 'static-resources'\n}));\n\n//# sourceURL=webpack://react-pwa-netflix/./src/src-sw.js?");

/***/ }),

/***/ "./node_modules/workbox-cacheable-response/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/workbox-cacheable-response/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheableResponse\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.CacheableResponse),\n/* harmony export */   \"CacheableResponsePlugin\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.CacheableResponsePlugin)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-cacheable-response/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-cacheable-response/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-core/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/workbox-core/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_private\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__._private),\n/* harmony export */   \"cacheNames\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.cacheNames),\n/* harmony export */   \"clientsClaim\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.clientsClaim),\n/* harmony export */   \"copyResponse\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.copyResponse),\n/* harmony export */   \"registerQuotaErrorCallback\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.registerQuotaErrorCallback),\n/* harmony export */   \"setCacheNameDetails\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.setCacheNameDetails),\n/* harmony export */   \"skipWaiting\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.skipWaiting)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-core/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-core/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-expiration/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/workbox-expiration/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheExpiration\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.CacheExpiration),\n/* harmony export */   \"ExpirationPlugin\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.ExpirationPlugin)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-expiration/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-expiration/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-precaching/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/workbox-precaching/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PrecacheController\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.PrecacheController),\n/* harmony export */   \"PrecacheFallbackPlugin\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.PrecacheFallbackPlugin),\n/* harmony export */   \"PrecacheRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.PrecacheRoute),\n/* harmony export */   \"PrecacheStrategy\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.PrecacheStrategy),\n/* harmony export */   \"addPlugins\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.addPlugins),\n/* harmony export */   \"addRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.addRoute),\n/* harmony export */   \"cleanupOutdatedCaches\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.cleanupOutdatedCaches),\n/* harmony export */   \"createHandlerBoundToURL\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.createHandlerBoundToURL),\n/* harmony export */   \"getCacheKeyForURL\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.getCacheKeyForURL),\n/* harmony export */   \"matchPrecache\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.matchPrecache),\n/* harmony export */   \"precache\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.precache),\n/* harmony export */   \"precacheAndRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.precacheAndRoute)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-precaching/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-precaching/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-routing/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/workbox-routing/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NavigationRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.NavigationRoute),\n/* harmony export */   \"RegExpRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.RegExpRoute),\n/* harmony export */   \"Route\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.Route),\n/* harmony export */   \"Router\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.Router),\n/* harmony export */   \"registerRoute\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.registerRoute),\n/* harmony export */   \"setCatchHandler\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.setCatchHandler),\n/* harmony export */   \"setDefaultHandler\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.setDefaultHandler)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-routing/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-routing/index.mjs?");

/***/ }),

/***/ "./node_modules/workbox-strategies/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/workbox-strategies/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CacheFirst\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.CacheFirst),\n/* harmony export */   \"CacheOnly\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.CacheOnly),\n/* harmony export */   \"NetworkFirst\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.NetworkFirst),\n/* harmony export */   \"NetworkOnly\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.NetworkOnly),\n/* harmony export */   \"StaleWhileRevalidate\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.StaleWhileRevalidate),\n/* harmony export */   \"Strategy\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.Strategy),\n/* harmony export */   \"StrategyHandler\": () => (/* reexport safe */ _index_js__WEBPACK_IMPORTED_MODULE_0__.StrategyHandler)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./node_modules/workbox-strategies/index.js\");\n\n\n//# sourceURL=webpack://react-pwa-netflix/./node_modules/workbox-strategies/index.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/src-sw.js");
/******/ 	
/******/ })()
;